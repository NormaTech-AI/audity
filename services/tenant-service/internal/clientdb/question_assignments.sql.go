// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: question_assignments.sql

package clientdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkAssignQuestionsParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	AssignedTo uuid.UUID `json:"assigned_to"`
	AssignedBy uuid.UUID `json:"assigned_by"`
	Notes      *string   `json:"notes"`
}

const CreateQuestionAssignment = `-- name: CreateQuestionAssignment :one
INSERT INTO question_assignments (
    question_id,
    assigned_to,
    assigned_by,
    notes
) VALUES (
    $1, $2, $3, $4
) RETURNING id, question_id, assigned_to, assigned_by, assigned_at, notes
`

type CreateQuestionAssignmentParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	AssignedTo uuid.UUID `json:"assigned_to"`
	AssignedBy uuid.UUID `json:"assigned_by"`
	Notes      *string   `json:"notes"`
}

func (q *Queries) CreateQuestionAssignment(ctx context.Context, arg CreateQuestionAssignmentParams) (QuestionAssignment, error) {
	row := q.db.QueryRow(ctx, CreateQuestionAssignment,
		arg.QuestionID,
		arg.AssignedTo,
		arg.AssignedBy,
		arg.Notes,
	)
	var i QuestionAssignment
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.AssignedTo,
		&i.AssignedBy,
		&i.AssignedAt,
		&i.Notes,
	)
	return i, err
}

const DeleteQuestionAssignment = `-- name: DeleteQuestionAssignment :exec
DELETE FROM question_assignments
WHERE question_id = $1 AND assigned_to = $2
`

type DeleteQuestionAssignmentParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	AssignedTo uuid.UUID `json:"assigned_to"`
}

func (q *Queries) DeleteQuestionAssignment(ctx context.Context, arg DeleteQuestionAssignmentParams) error {
	_, err := q.db.Exec(ctx, DeleteQuestionAssignment, arg.QuestionID, arg.AssignedTo)
	return err
}

const GetQuestionAssignment = `-- name: GetQuestionAssignment :one
SELECT id, question_id, assigned_to, assigned_by, assigned_at, notes FROM question_assignments
WHERE question_id = $1 AND assigned_to = $2
`

type GetQuestionAssignmentParams struct {
	QuestionID uuid.UUID `json:"question_id"`
	AssignedTo uuid.UUID `json:"assigned_to"`
}

func (q *Queries) GetQuestionAssignment(ctx context.Context, arg GetQuestionAssignmentParams) (QuestionAssignment, error) {
	row := q.db.QueryRow(ctx, GetQuestionAssignment, arg.QuestionID, arg.AssignedTo)
	var i QuestionAssignment
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.AssignedTo,
		&i.AssignedBy,
		&i.AssignedAt,
		&i.Notes,
	)
	return i, err
}

const ListAssignmentsByQuestion = `-- name: ListAssignmentsByQuestion :many
SELECT id, question_id, assigned_to, assigned_by, assigned_at, notes FROM question_assignments
WHERE question_id = $1
ORDER BY assigned_at DESC
`

func (q *Queries) ListAssignmentsByQuestion(ctx context.Context, questionID uuid.UUID) ([]QuestionAssignment, error) {
	rows, err := q.db.Query(ctx, ListAssignmentsByQuestion, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []QuestionAssignment{}
	for rows.Next() {
		var i QuestionAssignment
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.AssignedTo,
			&i.AssignedBy,
			&i.AssignedAt,
			&i.Notes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAssignmentsByUser = `-- name: ListAssignmentsByUser :many
SELECT 
    qa.id, qa.question_id, qa.assigned_to, qa.assigned_by, qa.assigned_at, qa.notes,
    q.question_text,
    q.section,
    q.audit_id,
    s.status as submission_status
FROM question_assignments qa
JOIN questions q ON q.id = qa.question_id
LEFT JOIN submissions s ON s.question_id = q.id
WHERE qa.assigned_to = $1
ORDER BY qa.assigned_at DESC
`

type ListAssignmentsByUserRow struct {
	ID               uuid.UUID                `json:"id"`
	QuestionID       uuid.UUID                `json:"question_id"`
	AssignedTo       uuid.UUID                `json:"assigned_to"`
	AssignedBy       uuid.UUID                `json:"assigned_by"`
	AssignedAt       pgtype.Timestamptz       `json:"assigned_at"`
	Notes            *string                  `json:"notes"`
	QuestionText     string                   `json:"question_text"`
	Section          string                   `json:"section"`
	AuditID          uuid.UUID                `json:"audit_id"`
	SubmissionStatus NullSubmissionStatusEnum `json:"submission_status"`
}

func (q *Queries) ListAssignmentsByUser(ctx context.Context, assignedTo uuid.UUID) ([]ListAssignmentsByUserRow, error) {
	rows, err := q.db.Query(ctx, ListAssignmentsByUser, assignedTo)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAssignmentsByUserRow{}
	for rows.Next() {
		var i ListAssignmentsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.AssignedTo,
			&i.AssignedBy,
			&i.AssignedAt,
			&i.Notes,
			&i.QuestionText,
			&i.Section,
			&i.AuditID,
			&i.SubmissionStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
