// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: questions.sql

package clientdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateQuestionsParams struct {
	AuditID        uuid.UUID        `json:"audit_id"`
	Section        string           `json:"section"`
	QuestionNumber string           `json:"question_number"`
	QuestionText   string           `json:"question_text"`
	QuestionType   QuestionTypeEnum `json:"question_type"`
	HelpText       *string          `json:"help_text"`
	IsMandatory    bool             `json:"is_mandatory"`
	DisplayOrder   int32            `json:"display_order"`
}

const CreateQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (
    audit_id,
    section,
    question_number,
    question_text,
    question_type,
    help_text,
    is_mandatory,
    display_order
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING id, audit_id, section, question_number, question_text, question_type, help_text, is_mandatory, display_order, created_at, updated_at
`

type CreateQuestionParams struct {
	AuditID        uuid.UUID        `json:"audit_id"`
	Section        string           `json:"section"`
	QuestionNumber string           `json:"question_number"`
	QuestionText   string           `json:"question_text"`
	QuestionType   QuestionTypeEnum `json:"question_type"`
	HelpText       *string          `json:"help_text"`
	IsMandatory    bool             `json:"is_mandatory"`
	DisplayOrder   int32            `json:"display_order"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, CreateQuestion,
		arg.AuditID,
		arg.Section,
		arg.QuestionNumber,
		arg.QuestionText,
		arg.QuestionType,
		arg.HelpText,
		arg.IsMandatory,
		arg.DisplayOrder,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.AuditID,
		&i.Section,
		&i.QuestionNumber,
		&i.QuestionText,
		&i.QuestionType,
		&i.HelpText,
		&i.IsMandatory,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteQuestion = `-- name: DeleteQuestion :exec
DELETE FROM questions
WHERE id = $1
`

func (q *Queries) DeleteQuestion(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteQuestion, id)
	return err
}

const GetQuestionByID = `-- name: GetQuestionByID :one
SELECT id, audit_id, section, question_number, question_text, question_type, help_text, is_mandatory, display_order, created_at, updated_at FROM questions
WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id uuid.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, GetQuestionByID, id)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.AuditID,
		&i.Section,
		&i.QuestionNumber,
		&i.QuestionText,
		&i.QuestionType,
		&i.HelpText,
		&i.IsMandatory,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetQuestionWithSubmission = `-- name: GetQuestionWithSubmission :one
SELECT 
    q.id, q.audit_id, q.section, q.question_number, q.question_text, q.question_type, q.help_text, q.is_mandatory, q.display_order, q.created_at, q.updated_at,
    s.id as submission_id,
    s.answer_value,
    s.answer_text,
    s.explanation,
    s.status as submission_status,
    s.submitted_at,
    s.reviewed_by,
    s.reviewed_at,
    s.review_notes
FROM questions q
LEFT JOIN submissions s ON s.question_id = q.id
WHERE q.id = $1
`

type GetQuestionWithSubmissionRow struct {
	ID               uuid.UUID                `json:"id"`
	AuditID          uuid.UUID                `json:"audit_id"`
	Section          string                   `json:"section"`
	QuestionNumber   string                   `json:"question_number"`
	QuestionText     string                   `json:"question_text"`
	QuestionType     QuestionTypeEnum         `json:"question_type"`
	HelpText         *string                  `json:"help_text"`
	IsMandatory      bool                     `json:"is_mandatory"`
	DisplayOrder     int32                    `json:"display_order"`
	CreatedAt        pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz       `json:"updated_at"`
	SubmissionID     pgtype.UUID              `json:"submission_id"`
	AnswerValue      NullAnswerValueEnum      `json:"answer_value"`
	AnswerText       *string                  `json:"answer_text"`
	Explanation      *string                  `json:"explanation"`
	SubmissionStatus NullSubmissionStatusEnum `json:"submission_status"`
	SubmittedAt      pgtype.Timestamptz       `json:"submitted_at"`
	ReviewedBy       pgtype.UUID              `json:"reviewed_by"`
	ReviewedAt       pgtype.Timestamptz       `json:"reviewed_at"`
	ReviewNotes      *string                  `json:"review_notes"`
}

func (q *Queries) GetQuestionWithSubmission(ctx context.Context, id uuid.UUID) (GetQuestionWithSubmissionRow, error) {
	row := q.db.QueryRow(ctx, GetQuestionWithSubmission, id)
	var i GetQuestionWithSubmissionRow
	err := row.Scan(
		&i.ID,
		&i.AuditID,
		&i.Section,
		&i.QuestionNumber,
		&i.QuestionText,
		&i.QuestionType,
		&i.HelpText,
		&i.IsMandatory,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SubmissionID,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.SubmissionStatus,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
	)
	return i, err
}

const ListQuestionsByAudit = `-- name: ListQuestionsByAudit :many
SELECT id, audit_id, section, question_number, question_text, question_type, help_text, is_mandatory, display_order, created_at, updated_at FROM questions
WHERE audit_id = $1
ORDER BY display_order ASC
`

func (q *Queries) ListQuestionsByAudit(ctx context.Context, auditID uuid.UUID) ([]Question, error) {
	rows, err := q.db.Query(ctx, ListQuestionsByAudit, auditID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.AuditID,
			&i.Section,
			&i.QuestionNumber,
			&i.QuestionText,
			&i.QuestionType,
			&i.HelpText,
			&i.IsMandatory,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListQuestionsBySection = `-- name: ListQuestionsBySection :many
SELECT id, audit_id, section, question_number, question_text, question_type, help_text, is_mandatory, display_order, created_at, updated_at FROM questions
WHERE audit_id = $1 AND section = $2
ORDER BY display_order ASC
`

type ListQuestionsBySectionParams struct {
	AuditID uuid.UUID `json:"audit_id"`
	Section string    `json:"section"`
}

func (q *Queries) ListQuestionsBySection(ctx context.Context, arg ListQuestionsBySectionParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, ListQuestionsBySection, arg.AuditID, arg.Section)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.ID,
			&i.AuditID,
			&i.Section,
			&i.QuestionNumber,
			&i.QuestionText,
			&i.QuestionType,
			&i.HelpText,
			&i.IsMandatory,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListQuestionsWithSubmissions = `-- name: ListQuestionsWithSubmissions :many
SELECT 
    q.id, q.audit_id, q.section, q.question_number, q.question_text, q.question_type, q.help_text, q.is_mandatory, q.display_order, q.created_at, q.updated_at,
    s.id as submission_id,
    s.status as submission_status,
    s.submitted_at
FROM questions q
LEFT JOIN submissions s ON s.question_id = q.id
WHERE q.audit_id = $1
ORDER BY q.display_order ASC
`

type ListQuestionsWithSubmissionsRow struct {
	ID               uuid.UUID                `json:"id"`
	AuditID          uuid.UUID                `json:"audit_id"`
	Section          string                   `json:"section"`
	QuestionNumber   string                   `json:"question_number"`
	QuestionText     string                   `json:"question_text"`
	QuestionType     QuestionTypeEnum         `json:"question_type"`
	HelpText         *string                  `json:"help_text"`
	IsMandatory      bool                     `json:"is_mandatory"`
	DisplayOrder     int32                    `json:"display_order"`
	CreatedAt        pgtype.Timestamptz       `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz       `json:"updated_at"`
	SubmissionID     pgtype.UUID              `json:"submission_id"`
	SubmissionStatus NullSubmissionStatusEnum `json:"submission_status"`
	SubmittedAt      pgtype.Timestamptz       `json:"submitted_at"`
}

func (q *Queries) ListQuestionsWithSubmissions(ctx context.Context, auditID uuid.UUID) ([]ListQuestionsWithSubmissionsRow, error) {
	rows, err := q.db.Query(ctx, ListQuestionsWithSubmissions, auditID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListQuestionsWithSubmissionsRow{}
	for rows.Next() {
		var i ListQuestionsWithSubmissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuditID,
			&i.Section,
			&i.QuestionNumber,
			&i.QuestionText,
			&i.QuestionType,
			&i.HelpText,
			&i.IsMandatory,
			&i.DisplayOrder,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SubmissionID,
			&i.SubmissionStatus,
			&i.SubmittedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET 
    question_text = COALESCE($2, question_text),
    help_text = COALESCE($3, help_text),
    is_mandatory = COALESCE($4, is_mandatory)
WHERE id = $1
RETURNING id, audit_id, section, question_number, question_text, question_type, help_text, is_mandatory, display_order, created_at, updated_at
`

type UpdateQuestionParams struct {
	ID           uuid.UUID `json:"id"`
	QuestionText string    `json:"question_text"`
	HelpText     *string   `json:"help_text"`
	IsMandatory  bool      `json:"is_mandatory"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, UpdateQuestion,
		arg.ID,
		arg.QuestionText,
		arg.HelpText,
		arg.IsMandatory,
	)
	var i Question
	err := row.Scan(
		&i.ID,
		&i.AuditID,
		&i.Section,
		&i.QuestionNumber,
		&i.QuestionText,
		&i.QuestionType,
		&i.HelpText,
		&i.IsMandatory,
		&i.DisplayOrder,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
