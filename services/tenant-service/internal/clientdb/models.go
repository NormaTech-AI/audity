// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package clientdb

import (
	"database/sql/driver"
	"fmt"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type AnswerValueEnum string

const (
	AnswerValueEnumYes AnswerValueEnum = "yes"
	AnswerValueEnumNo  AnswerValueEnum = "no"
	AnswerValueEnumNa  AnswerValueEnum = "na"
)

func (e *AnswerValueEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AnswerValueEnum(s)
	case string:
		*e = AnswerValueEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AnswerValueEnum: %T", src)
	}
	return nil
}

type NullAnswerValueEnum struct {
	AnswerValueEnum AnswerValueEnum `json:"answer_value_enum"`
	Valid           bool            `json:"valid"` // Valid is true if AnswerValueEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAnswerValueEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AnswerValueEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AnswerValueEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAnswerValueEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AnswerValueEnum), nil
}

func (e AnswerValueEnum) Valid() bool {
	switch e {
	case AnswerValueEnumYes,
		AnswerValueEnumNo,
		AnswerValueEnumNa:
		return true
	}
	return false
}

func AllAnswerValueEnumValues() []AnswerValueEnum {
	return []AnswerValueEnum{
		AnswerValueEnumYes,
		AnswerValueEnumNo,
		AnswerValueEnumNa,
	}
}

type AuditStatusEnum string

const (
	AuditStatusEnumNotStarted  AuditStatusEnum = "not_started"
	AuditStatusEnumInProgress  AuditStatusEnum = "in_progress"
	AuditStatusEnumUnderReview AuditStatusEnum = "under_review"
	AuditStatusEnumCompleted   AuditStatusEnum = "completed"
	AuditStatusEnumOverdue     AuditStatusEnum = "overdue"
)

func (e *AuditStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = AuditStatusEnum(s)
	case string:
		*e = AuditStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for AuditStatusEnum: %T", src)
	}
	return nil
}

type NullAuditStatusEnum struct {
	AuditStatusEnum AuditStatusEnum `json:"audit_status_enum"`
	Valid           bool            `json:"valid"` // Valid is true if AuditStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullAuditStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.AuditStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.AuditStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullAuditStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.AuditStatusEnum), nil
}

func (e AuditStatusEnum) Valid() bool {
	switch e {
	case AuditStatusEnumNotStarted,
		AuditStatusEnumInProgress,
		AuditStatusEnumUnderReview,
		AuditStatusEnumCompleted,
		AuditStatusEnumOverdue:
		return true
	}
	return false
}

func AllAuditStatusEnumValues() []AuditStatusEnum {
	return []AuditStatusEnum{
		AuditStatusEnumNotStarted,
		AuditStatusEnumInProgress,
		AuditStatusEnumUnderReview,
		AuditStatusEnumCompleted,
		AuditStatusEnumOverdue,
	}
}

type ClientUserRoleEnum string

const (
	ClientUserRoleEnumClientAdmin ClientUserRoleEnum = "client_admin"
	ClientUserRoleEnumPoc         ClientUserRoleEnum = "poc"
	ClientUserRoleEnumStakeholder ClientUserRoleEnum = "stakeholder"
	ClientUserRoleEnumViewer      ClientUserRoleEnum = "viewer"
)

func (e *ClientUserRoleEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ClientUserRoleEnum(s)
	case string:
		*e = ClientUserRoleEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for ClientUserRoleEnum: %T", src)
	}
	return nil
}

type NullClientUserRoleEnum struct {
	ClientUserRoleEnum ClientUserRoleEnum `json:"client_user_role_enum"`
	Valid              bool               `json:"valid"` // Valid is true if ClientUserRoleEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullClientUserRoleEnum) Scan(value interface{}) error {
	if value == nil {
		ns.ClientUserRoleEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ClientUserRoleEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullClientUserRoleEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ClientUserRoleEnum), nil
}

func (e ClientUserRoleEnum) Valid() bool {
	switch e {
	case ClientUserRoleEnumClientAdmin,
		ClientUserRoleEnumPoc,
		ClientUserRoleEnumStakeholder,
		ClientUserRoleEnumViewer:
		return true
	}
	return false
}

func AllClientUserRoleEnumValues() []ClientUserRoleEnum {
	return []ClientUserRoleEnum{
		ClientUserRoleEnumClientAdmin,
		ClientUserRoleEnumPoc,
		ClientUserRoleEnumStakeholder,
		ClientUserRoleEnumViewer,
	}
}

type QuestionTypeEnum string

const (
	QuestionTypeEnumYesNo          QuestionTypeEnum = "yes_no"
	QuestionTypeEnumText           QuestionTypeEnum = "text"
	QuestionTypeEnumMultipleChoice QuestionTypeEnum = "multiple_choice"
)

func (e *QuestionTypeEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = QuestionTypeEnum(s)
	case string:
		*e = QuestionTypeEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for QuestionTypeEnum: %T", src)
	}
	return nil
}

type NullQuestionTypeEnum struct {
	QuestionTypeEnum QuestionTypeEnum `json:"question_type_enum"`
	Valid            bool             `json:"valid"` // Valid is true if QuestionTypeEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullQuestionTypeEnum) Scan(value interface{}) error {
	if value == nil {
		ns.QuestionTypeEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.QuestionTypeEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullQuestionTypeEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.QuestionTypeEnum), nil
}

func (e QuestionTypeEnum) Valid() bool {
	switch e {
	case QuestionTypeEnumYesNo,
		QuestionTypeEnumText,
		QuestionTypeEnumMultipleChoice:
		return true
	}
	return false
}

func AllQuestionTypeEnumValues() []QuestionTypeEnum {
	return []QuestionTypeEnum{
		QuestionTypeEnumYesNo,
		QuestionTypeEnumText,
		QuestionTypeEnumMultipleChoice,
	}
}

type ReportStatusEnum string

const (
	ReportStatusEnumPending   ReportStatusEnum = "pending"
	ReportStatusEnumGenerated ReportStatusEnum = "generated"
	ReportStatusEnumSigned    ReportStatusEnum = "signed"
	ReportStatusEnumDelivered ReportStatusEnum = "delivered"
)

func (e *ReportStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ReportStatusEnum(s)
	case string:
		*e = ReportStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for ReportStatusEnum: %T", src)
	}
	return nil
}

type NullReportStatusEnum struct {
	ReportStatusEnum ReportStatusEnum `json:"report_status_enum"`
	Valid            bool             `json:"valid"` // Valid is true if ReportStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullReportStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.ReportStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ReportStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullReportStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ReportStatusEnum), nil
}

func (e ReportStatusEnum) Valid() bool {
	switch e {
	case ReportStatusEnumPending,
		ReportStatusEnumGenerated,
		ReportStatusEnumSigned,
		ReportStatusEnumDelivered:
		return true
	}
	return false
}

func AllReportStatusEnumValues() []ReportStatusEnum {
	return []ReportStatusEnum{
		ReportStatusEnumPending,
		ReportStatusEnumGenerated,
		ReportStatusEnumSigned,
		ReportStatusEnumDelivered,
	}
}

type SubmissionStatusEnum string

const (
	SubmissionStatusEnumNotStarted SubmissionStatusEnum = "not_started"
	SubmissionStatusEnumInProgress SubmissionStatusEnum = "in_progress"
	SubmissionStatusEnumSubmitted  SubmissionStatusEnum = "submitted"
	SubmissionStatusEnumApproved   SubmissionStatusEnum = "approved"
	SubmissionStatusEnumRejected   SubmissionStatusEnum = "rejected"
	SubmissionStatusEnumReferred   SubmissionStatusEnum = "referred"
)

func (e *SubmissionStatusEnum) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = SubmissionStatusEnum(s)
	case string:
		*e = SubmissionStatusEnum(s)
	default:
		return fmt.Errorf("unsupported scan type for SubmissionStatusEnum: %T", src)
	}
	return nil
}

type NullSubmissionStatusEnum struct {
	SubmissionStatusEnum SubmissionStatusEnum `json:"submission_status_enum"`
	Valid                bool                 `json:"valid"` // Valid is true if SubmissionStatusEnum is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullSubmissionStatusEnum) Scan(value interface{}) error {
	if value == nil {
		ns.SubmissionStatusEnum, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.SubmissionStatusEnum.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullSubmissionStatusEnum) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.SubmissionStatusEnum), nil
}

func (e SubmissionStatusEnum) Valid() bool {
	switch e {
	case SubmissionStatusEnumNotStarted,
		SubmissionStatusEnumInProgress,
		SubmissionStatusEnumSubmitted,
		SubmissionStatusEnumApproved,
		SubmissionStatusEnumRejected,
		SubmissionStatusEnumReferred:
		return true
	}
	return false
}

func AllSubmissionStatusEnumValues() []SubmissionStatusEnum {
	return []SubmissionStatusEnum{
		SubmissionStatusEnumNotStarted,
		SubmissionStatusEnumInProgress,
		SubmissionStatusEnumSubmitted,
		SubmissionStatusEnumApproved,
		SubmissionStatusEnumRejected,
		SubmissionStatusEnumReferred,
	}
}

// Audit trail of all tenant activities
type ActivityLog struct {
	ID         uuid.UUID          `json:"id"`
	UserID     uuid.UUID          `json:"user_id"`
	UserEmail  string             `json:"user_email"`
	Action     string             `json:"action"`
	EntityType string             `json:"entity_type"`
	EntityID   uuid.UUID          `json:"entity_id"`
	Details    []byte             `json:"details"`
	IpAddress  *string            `json:"ip_address"`
	UserAgent  *string            `json:"user_agent"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

// Audit assignments for this tenant
type Audit struct {
	ID            uuid.UUID          `json:"id"`
	FrameworkID   uuid.UUID          `json:"framework_id"`
	FrameworkName string             `json:"framework_name"`
	AssignedBy    uuid.UUID          `json:"assigned_by"`
	AssignedTo    pgtype.UUID        `json:"assigned_to"`
	DueDate       pgtype.Date        `json:"due_date"`
	Status        AuditStatusEnum    `json:"status"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	CompletedAt   pgtype.Timestamptz `json:"completed_at"`
}

// Client-specific RBAC permissions
type ClientPermission struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	Resource    string             `json:"resource"`
	Action      string             `json:"action"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

// Client-specific RBAC roles
type ClientRole struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	Description *string            `json:"description"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

// Mapping between roles and permissions
type ClientRolePermission struct {
	RoleID       uuid.UUID `json:"role_id"`
	PermissionID uuid.UUID `json:"permission_id"`
}

// Client-specific user mappings with roles
type ClientUser struct {
	ID           uuid.UUID          `json:"id"`
	TenantUserID uuid.UUID          `json:"tenant_user_id"`
	Email        string             `json:"email"`
	Name         string             `json:"name"`
	Role         ClientUserRoleEnum `json:"role"`
	IsActive     bool               `json:"is_active"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	LastLogin    pgtype.Timestamptz `json:"last_login"`
}

// Mapping between users and roles
type ClientUserRole struct {
	UserID uuid.UUID `json:"user_id"`
	RoleID uuid.UUID `json:"role_id"`
}

// Discussion and comments on submissions
type Comment struct {
	ID           uuid.UUID          `json:"id"`
	SubmissionID uuid.UUID          `json:"submission_id"`
	UserID       uuid.UUID          `json:"user_id"`
	UserName     string             `json:"user_name"`
	CommentText  string             `json:"comment_text"`
	IsInternal   bool               `json:"is_internal"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
}

// Evidence files uploaded by client
type Evidence struct {
	ID           uuid.UUID          `json:"id"`
	SubmissionID uuid.UUID          `json:"submission_id"`
	FileName     string             `json:"file_name"`
	FilePath     string             `json:"file_path"`
	FileSize     int64              `json:"file_size"`
	FileType     *string            `json:"file_type"`
	UploadedBy   uuid.UUID          `json:"uploaded_by"`
	UploadedAt   pgtype.Timestamptz `json:"uploaded_at"`
	Description  *string            `json:"description"`
	IsDeleted    bool               `json:"is_deleted"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy    pgtype.UUID        `json:"deleted_by"`
}

// Questions from compliance frameworks
type Question struct {
	ID             uuid.UUID          `json:"id"`
	AuditID        uuid.UUID          `json:"audit_id"`
	Section        string             `json:"section"`
	QuestionNumber string             `json:"question_number"`
	QuestionText   string             `json:"question_text"`
	QuestionType   QuestionTypeEnum   `json:"question_type"`
	HelpText       *string            `json:"help_text"`
	IsMandatory    bool               `json:"is_mandatory"`
	DisplayOrder   int32              `json:"display_order"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
}

// Delegation of questions to stakeholders
type QuestionAssignment struct {
	ID         uuid.UUID          `json:"id"`
	QuestionID uuid.UUID          `json:"question_id"`
	AssignedTo uuid.UUID          `json:"assigned_to"`
	AssignedBy uuid.UUID          `json:"assigned_by"`
	AssignedAt pgtype.Timestamptz `json:"assigned_at"`
	Notes      *string            `json:"notes"`
}

// Generated audit reports
type Report struct {
	ID               uuid.UUID          `json:"id"`
	AuditID          uuid.UUID          `json:"audit_id"`
	UnsignedFilePath *string            `json:"unsigned_file_path"`
	SignedFilePath   *string            `json:"signed_file_path"`
	GeneratedBy      uuid.UUID          `json:"generated_by"`
	GeneratedAt      pgtype.Timestamptz `json:"generated_at"`
	SignedBy         pgtype.UUID        `json:"signed_by"`
	SignedAt         pgtype.Timestamptz `json:"signed_at"`
	Status           ReportStatusEnum   `json:"status"`
	Metadata         []byte             `json:"metadata"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

// Client answers and submissions
type Submission struct {
	ID              uuid.UUID            `json:"id"`
	QuestionID      uuid.UUID            `json:"question_id"`
	SubmittedBy     uuid.UUID            `json:"submitted_by"`
	AnswerValue     NullAnswerValueEnum  `json:"answer_value"`
	AnswerText      *string              `json:"answer_text"`
	Explanation     string               `json:"explanation"`
	Status          SubmissionStatusEnum `json:"status"`
	SubmittedAt     pgtype.Timestamptz   `json:"submitted_at"`
	ReviewedBy      pgtype.UUID          `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `json:"reviewed_at"`
	ReviewNotes     *string              `json:"review_notes"`
	RejectionReason *string              `json:"rejection_reason"`
	Version         int32                `json:"version"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
}
