# TPRM Audit Platform - Development Progress

## Phase 1: Database Foundation ✅ COMPLETED

### What Was Implemented

#### 1. Database Schema & Migrations
- ✅ Created comprehensive PostgreSQL schema for `tenant_db`
- ✅ Implemented enum types: `client_status_enum`, `user_role_enum`, `audit_status_enum`
- ✅ Core tables created:
  - `clients` - Main tenant registry
  - `client_databases` - Encrypted DB credentials per tenant
  - `client_buckets` - MinIO bucket info per tenant
  - `compliance_frameworks` - NSE, BSE, NCDEX checklists
  - `client_frameworks` - Framework assignments with due dates
  - `users` - OIDC user mapping
  - `roles` & `permissions` - RBAC system
  - `role_permissions` & `user_roles` - Permission mappings
  - `audit_logs` - Audit trail
- ✅ Automatic `updated_at` triggers
- ✅ Proper indexes for performance

#### 2. Database Migrations
- ✅ Installed `golang-migrate`
- ✅ Created migration files:
  - `000001_init_tenant_schema.up.sql` / `.down.sql`
  - `000002_seed_roles_permissions.up.sql` / `.down.sql`
- ✅ Successfully ran migrations on PostgreSQL
- ✅ Seeded 6 default roles with appropriate permissions

#### 3. Type-Safe Database Access (sqlc)
- ✅ Configured `sqlc.yaml` for code generation
- ✅ Created SQL queries for all tables:
  - `clients.sql` - CRUD operations
  - `client_databases.sql` - DB credential management
  - `client_buckets.sql` - Bucket management
  - `frameworks.sql` - Framework CRUD
  - `client_frameworks.sql` - Framework assignments
  - `users.sql` - User management
  - `roles.sql` - Role operations
  - `permissions.sql` - Permission checks
  - `audit_logs.sql` - Logging operations
- ✅ Generated type-safe Go code in `internal/db/`

#### 4. Configuration Management (Viper)
- ✅ Created `internal/config/config.go` with structured config
- ✅ Implemented `config.yaml` with:
  - Server settings (host, port, env)
  - Database connection pooling
  - MinIO credentials
  - Auth settings (JWT, OIDC placeholders)
  - Crypto settings (AES-256 encryption key)
- ✅ Environment variable overrides with `AUDITY_` prefix
- ✅ Config validation

#### 5. Core Infrastructure
- ✅ **Store Layer** (`internal/store/store.go`)
  - Connection pool wrapper
  - Transaction support with `ExecTx`
  - Ping and health checks
  
- ✅ **Encryption** (`internal/crypto/crypto.go`)
  - AES-256-GCM encryption for DB passwords
  - Secure key management
  
- ✅ **Handlers** (`internal/handler/`)
  - `handler.go` - Base handler with dependencies
  - `health.go` - Health check endpoints
  - `client.go` - Client management with tenant provisioning
  
- ✅ **Router** (`internal/router/router.go`)
  - Echo middleware setup (Logger, Recover, CORS, RequestID)
  - Route organization by feature
  - Swagger documentation endpoint
  
- ✅ **Validator** (`internal/validator/validator.go`)
  - Custom Echo validator using go-playground/validator

#### 6. API Endpoints Implemented
- ✅ `GET /` - Service info
- ✅ `GET /health` - Health check with DB status
- ✅ `GET /swagger/*` - API documentation
- ✅ `POST /api/clients` - Create client with auto-provisioning
- ✅ `GET /api/clients` - List all clients
- ✅ `GET /api/clients/:id` - Get client by ID

#### 7. Tenant Provisioning Logic
- ✅ Automatic database creation per client
- ✅ Automatic database user creation with secure passwords
- ✅ Automatic MinIO bucket creation
- ✅ Encrypted storage of DB credentials
- ✅ Transaction-based provisioning (all-or-nothing)

#### 8. Development Tools
- ✅ Created `Makefile` with common tasks:
  - `make migrate-up` / `migrate-down`
  - `make sqlc-generate`
  - `make dev` / `make build`
  - `make install-tools`
- ✅ Configured Air for hot reload (`.air.toml`)
- ✅ Swagger documentation generation

### Files Created/Modified

```
services/tenant-service/
├── db/
│   ├── migrations/
│   │   ├── 000001_init_tenant_schema.up.sql
│   │   ├── 000001_init_tenant_schema.down.sql
│   │   ├── 000002_seed_roles_permissions.up.sql
│   │   └── 000002_seed_roles_permissions.down.sql
│   └── queries/
│       ├── clients.sql
│       ├── client_databases.sql
│       ├── client_buckets.sql
│       ├── frameworks.sql
│       ├── client_frameworks.sql
│       ├── users.sql
│       ├── roles.sql
│       ├── permissions.sql
│       └── audit_logs.sql
├── internal/
│   ├── config/
│   │   └── config.go
│   ├── crypto/
│   │   └── crypto.go
│   ├── db/
│   │   ├── *.sql.go (generated by sqlc)
│   │   ├── models.go
│   │   └── querier.go
│   ├── handler/
│   │   ├── handler.go
│   │   ├── health.go
│   │   └── client.go
│   ├── router/
│   │   └── router.go
│   ├── store/
│   │   └── store.go
│   └── validator/
│       └── validator.go
├── docs/ (generated by swag)
├── config.yaml
├── sqlc.yaml
├── Makefile
├── main.go (updated)
└── go.mod (updated with dependencies)
```

### Testing Results
- ✅ Service starts successfully on port 8081
- ✅ Database connection verified
- ✅ MinIO connection verified
- ✅ Health endpoint returns 200 OK
- ✅ API endpoints respond correctly
- ✅ Swagger docs accessible at `/swagger/index.html`

### Dependencies Added
```go
github.com/go-playground/validator/v10 v10.24.0
github.com/google/uuid v1.6.0
github.com/jackc/pgx/v5 v5.7.6
github.com/labstack/echo/v4 v4.13.4
github.com/minio/minio-go/v7 v7.0.80
github.com/spf13/viper v1.19.0
github.com/swaggo/echo-swagger v1.4.1
go.uber.org/zap v1.27.0
```

### Database Schema Summary

**Roles Created:**
1. `nishaj_admin` - Full system access
2. `auditor` - Review and approve submissions
3. `team_member` - Support staff
4. `poc_internal` - Internal relationship manager
5. `poc_client` - Client point of contact
6. `stakeholder` - Client employee (limited access)

**Permissions Created:** 30+ granular permissions across:
- Clients (create, read, update, delete, list)
- Frameworks (create, read, update, delete, list)
- Audits (create, read, update, delete, list, review)
- Questions (read, answer, delegate)
- Evidence (upload, read, delete)
- Reports (generate, read, sign, download)
- Users (create, read, update, delete, list)

---

## Phase 2: Authentication ✅ COMPLETED

### What Was Implemented

#### 1. Separate Auth Microservice
- ✅ Created dedicated `auth-service` on port 8082
- ✅ Independent from tenant-service for better scalability
- ✅ Shared access to `tenant_db` for user management
- ✅ Clean microservices architecture

#### 2. OAuth2/OIDC Integration
- ✅ Google OAuth2 provider
- ✅ Microsoft OAuth2 provider (Azure AD)
- ✅ State-based CSRF protection
- ✅ Automatic user info retrieval
- ✅ Configurable redirect URLs

#### 3. JWT Token System
- ✅ Token generation with user claims
- ✅ Token validation middleware
- ✅ Token refresh endpoint
- ✅ HS256 signing algorithm
- ✅ Configurable expiration (default 24h)
- ✅ Claims include: user_id, email, name, role, client_id

#### 4. User Management
- ✅ Auto-registration on first login
- ✅ OIDC provider mapping (Google/Microsoft)
- ✅ Default role assignment (stakeholder)
- ✅ Last login tracking
- ✅ Client association support

#### 5. API Endpoints
- ✅ `GET /auth/login/:provider` - Initiate OAuth
- ✅ `GET /auth/callback` - OAuth callback handler
- ✅ `POST /auth/refresh` - Refresh JWT token
- ✅ `POST /auth/logout` - Logout endpoint
- ✅ `GET /auth/validate` - Validate JWT (protected)
- ✅ `GET /health` - Health check

#### 6. Middleware & Security
- ✅ JWT validation middleware
- ✅ Bearer token extraction
- ✅ Claims injection into request context
- ✅ CORS support
- ✅ Request ID tracking
- ✅ Structured logging

#### 7. Infrastructure Updates
- ✅ Updated `docker-compose.yml` with auth-service
- ✅ Updated NGINX gateway for auth routing
- ✅ Health check endpoints for both services
- ✅ Proper service dependencies

#### 8. Documentation
- ✅ Comprehensive README for auth-service
- ✅ Swagger/OpenAPI documentation
- ✅ OAuth provider setup guides
- ✅ Authentication flow diagrams
- ✅ Security best practices

### Files Created

```
services/auth-service/
├── internal/
│   ├── auth/
│   │   ├── jwt.go          # JWT token management
│   │   └── oidc.go         # OAuth2/OIDC providers
│   ├── config/
│   │   └── config.go       # Configuration management
│   ├── handler/
│   │   ├── handler.go      # Base handler
│   │   ├── auth.go         # Auth endpoints
│   │   └── health.go       # Health checks
│   ├── middleware/
│   │   └── auth.go         # JWT validation middleware
│   ├── router/
│   │   └── router.go       # Route definitions
│   ├── store/
│   │   └── store.go        # Database access
│   └── validator/
│       └── validator.go    # Request validation
├── docs/                   # Swagger documentation
├── config.yaml            # Configuration file
├── Dockerfile             # Container definition
├── .air.toml              # Hot reload config
├── Makefile               # Development commands
├── README.md              # Service documentation
└── main.go                # Application entry point
```

### Architecture Updates

**Before (Monolithic):**
```
Frontend → Tenant Service (Auth + Business Logic)
```

**After (Microservices):**
```
                    ┌─────────────┐
                    │   Gateway   │
                    │   (NGINX)   │
                    └──────┬──────┘
                           │
              ┌────────────┴────────────┐
              │                         │
       ┌──────▼────────┐       ┌───────▼────────┐
       │ Auth Service  │       │ Tenant Service │
       │   (Port 8082) │       │   (Port 8081)  │
       └───────┬───────┘       └────────┬───────┘
               │                        │
               └────────┬───────────────┘
                        │
                ┌───────▼────────┐
                │   tenant_db    │
                │  (PostgreSQL)  │
                └────────────────┘
```

### Gateway Routing

```nginx
/auth/*           → auth-service:8082
/api/tenant/*     → tenant-service:8081
/health/auth      → auth-service:8082/health
/health/tenant    → tenant-service:8081/health
```

### Testing Results
- ✅ Auth service starts on port 8082
- ✅ Database connection verified
- ✅ Health endpoint returns 200 OK
- ✅ Swagger docs accessible
- ✅ JWT generation and validation working
- ✅ OAuth flow ready (requires provider credentials)

### OAuth Provider Configuration

To enable OAuth, add credentials to `config.yaml`:

```yaml
auth:
  google_client_id: "your-google-client-id"
  google_client_secret: "your-google-secret"
  microsoft_client_id: "your-microsoft-client-id"
  microsoft_client_secret: "your-microsoft-secret"
```

### Authentication Flow

1. **Frontend** → `GET /auth/login/google`
2. **Auth Service** → Returns OAuth URL
3. **User** → Redirects to Google/Microsoft
4. **Provider** → User authorizes
5. **Provider** → Redirects to `/auth/callback?code=...`
6. **Auth Service** → Exchanges code for token
7. **Auth Service** → Fetches user info
8. **Auth Service** → Creates/updates user in DB
9. **Auth Service** → Generates JWT
10. **Auth Service** → Redirects to frontend with JWT
11. **Frontend** → Stores JWT, uses for API calls

### Inter-Service Communication

Other services validate tokens by:
```go
// Import JWT manager
jwtManager := auth.NewJWTManager(jwtSecret, expirationHours)
claims, err := jwtManager.ValidateToken(tokenString)
```

Or via HTTP:
```bash
curl -H "Authorization: Bearer <token>" http://auth-service:8082/auth/validate
```

---

## Phase 3: RBAC Middleware ✅ COMPLETED

### What Was Implemented

#### 1. Authentication Middleware
- ✅ JWT token validation middleware
- ✅ Bearer token extraction from headers
- ✅ User claims injection into request context
- ✅ Automatic 401 responses for invalid tokens
- ✅ Context helper functions for user data access

#### 2. Permission-Based Middleware
- ✅ `PermissionMiddleware` - Single permission check
- ✅ `RequirePermissions` - Multiple permissions (AND logic)
- ✅ `RequireAnyPermission` - At least one permission (OR logic)
- ✅ Database-backed permission verification
- ✅ Automatic 403 responses for insufficient permissions

#### 3. Role-Based Middleware
- ✅ `RequireRole` - Single role check
- ✅ `RequireAnyRole` - Multiple roles (OR logic)
- ✅ Fast role validation from JWT claims
- ✅ No database queries for role checks

#### 4. Protected Routes
- ✅ All `/api/*` routes require authentication
- ✅ Client creation requires `clients:create` permission
- ✅ Client listing requires `clients:list` or `clients:read`
- ✅ Client viewing requires `clients:read` permission
- ✅ Public endpoints (health, swagger) remain open

#### 5. Permission System
- ✅ Permission naming convention: `resource:action`
- ✅ Database query optimization with indexes
- ✅ Efficient permission checking
- ✅ Detailed error messages with required permissions

#### 6. Security Features
- ✅ Least privilege principle enforced
- ✅ Granular access control
- ✅ Audit logging ready (user_id in context)
- ✅ Role hierarchy respected
- ✅ Client isolation support

#### 7. Documentation
- ✅ Comprehensive middleware README
- ✅ Usage examples for all middleware types
- ✅ Security best practices guide
- ✅ Troubleshooting guide
- ✅ Testing guidelines

### Files Created/Modified

```
services/tenant-service/
├── internal/
│   ├── middleware/
│   │   ├── auth.go          # JWT authentication middleware
│   │   ├── permission.go    # Permission-based middleware
│   │   └── README.md        # Complete documentation
│   └── router/
│       └── router.go        # Updated with RBAC protection
├── go.mod                   # Added golang-jwt dependency
└── main.go                  # Updated router setup
```

### Middleware Types

| Middleware | Purpose | Database Query |
|------------|---------|----------------|
| `AuthMiddleware` | Validate JWT token | No |
| `PermissionMiddleware` | Check single permission | Yes |
| `RequirePermissions` | Check multiple permissions (AND) | Yes |
| `RequireAnyPermission` | Check any permission (OR) | Yes |
| `RequireRole` | Check single role | No |
| `RequireAnyRole` | Check any role (OR) | No |

### Permission Examples

```go
// Single permission
custommiddleware.PermissionMiddleware(store, logger, "clients:create")

// Multiple permissions (AND)
custommiddleware.RequirePermissions(store, logger, "clients:update", "clients:read")

// Any permission (OR)
custommiddleware.RequireAnyPermission(store, logger, "clients:list", "clients:read")

// Single role
custommiddleware.RequireRole(logger, "nishaj_admin")

// Any role (OR)
custommiddleware.RequireAnyRole(logger, "nishaj_admin", "auditor")
```

### Protected Routes Example

```go
// All API routes require authentication
api := e.Group("/api")
api.Use(custommiddleware.AuthMiddleware(jwtSecret, logger))

// Admin only - create clients
clients.POST("", handler.CreateClient,
    custommiddleware.PermissionMiddleware(store, logger, "clients:create"))

// List clients - requires list or read permission
clients.GET("", handler.ListClients,
    custommiddleware.RequireAnyPermission(store, logger, "clients:list", "clients:read"))
```

### Permission Naming Convention

Format: `resource:action`

**Resources:**
- `clients` - Client management
- `frameworks` - Compliance frameworks
- `audits` - Audit assignments
- `questions` - Questionnaire management
- `evidence` - Evidence files
- `reports` - Audit reports
- `users` - User management

**Actions:**
- `create` - Create new resources
- `read` - View resources
- `update` - Modify resources
- `delete` - Remove resources
- `list` - List all resources
- `review` - Review submissions (audits)
- `upload` - Upload files (evidence)
- `download` - Download files (reports)
- `sign` - Sign documents (reports)
- `delegate` - Delegate tasks (questions)

### Error Responses

**401 Unauthorized:**
```json
{
  "error": "Missing authorization header"
}
```

**403 Forbidden:**
```json
{
  "error": "Insufficient permissions",
  "required": "clients:create",
  "user_role": "stakeholder"
}
```

### Testing Results
- ✅ Service builds successfully
- ✅ Middleware compiles without errors
- ✅ Routes properly protected
- ✅ Public endpoints remain accessible
- ✅ Ready for integration testing with auth-service

### Security Benefits

1. **Fine-Grained Control** - Permission-level access control
2. **Least Privilege** - Users get only required permissions
3. **Audit Trail** - User context available for logging
4. **Flexible Authorization** - Mix of role and permission checks
5. **Database-Backed** - Permissions can be changed without code deployment
6. **Performance** - Indexed queries for fast permission checks

### Usage in Handlers

```go
func (h *Handler) MyHandler(c echo.Context) error {
    // Get user from context
    user, err := middleware.GetUserFromContext(c)
    if err != nil {
        return c.JSON(http.StatusUnauthorized, map[string]string{
            "error": "User not found",
        })
    }

    // Access user properties
    userID := user.UserID
    email := user.Email
    role := user.Role
    clientID := user.ClientID

    // Use for business logic
    // ...
}
```

### Future Enhancements

- [ ] Permission caching with Redis
- [ ] Dynamic permission loading
- [ ] Permission inheritance
- [ ] Temporary permission grants
- [ ] Admin UI for permission management
- [ ] Bulk permission operations

---

## Monorepo Restructuring ✅ COMPLETED

### What Was Implemented

#### 1. Go Workspace Setup
- ✅ Created `go.work` for multi-module management
- ✅ Configured workspace with all modules
- ✅ Local package development enabled
- ✅ Automatic dependency resolution

#### 2. Shared Packages Created
- ✅ `packages/go/auth` - JWT & authentication middleware
- ✅ `packages/go/rbac` - Role-based access control middleware
- ✅ Proper module structure with go.mod files
- ✅ Comprehensive documentation

#### 3. Code Migration
- ✅ Moved JWT logic to shared auth package
- ✅ Moved auth middleware to shared package
- ✅ Moved RBAC middleware to shared package
- ✅ Eliminated all code duplication
- ✅ Updated all service imports

#### 4. Service Refactoring
- ✅ Auth-service uses shared auth package
- ✅ Tenant-service uses shared auth & rbac packages
- ✅ Reorganized OIDC code in auth-service
- ✅ Removed duplicate middleware directories
- ✅ Updated all import paths

#### 5. Build Verification
- ✅ Auth-service builds successfully
- ✅ Tenant-service builds successfully
- ✅ All modules tidy without errors
- ✅ Type-safe cross-module references

### Architecture Improvement

**Before:**
```
services/
├── auth-service/internal/auth/jwt.go (duplicated)
├── auth-service/internal/middleware/auth.go (duplicated)
└── tenant-service/internal/middleware/auth.go (duplicated)
```

**After:**
```
packages/go/
├── auth/ (shared)
│   ├── jwt.go
│   └── middleware.go
└── rbac/ (shared)
    └── permission.go

services/
├── auth-service/ (uses shared packages)
└── tenant-service/ (uses shared packages)
```

### Benefits Achieved

1. **Zero Code Duplication** - Single source of truth
2. **Type Safety** - Compile-time checks across modules
3. **Easy Maintenance** - Changes in one place
4. **Faster Development** - Reusable components
5. **Scalability** - Easy to add new services/packages
6. **Best Practices** - Follows Go monorepo patterns

### Shared Package Usage

```go
// In any service
import (
    "github.com/NormaTech-AI/audity/packages/go/auth"
    "github.com/NormaTech-AI/audity/packages/go/rbac"
)

// Use shared JWT manager
jwtManager := auth.NewJWTManager(secret, hours)
token, _ := jwtManager.GenerateToken(...)

// Use shared middleware
api.Use(auth.AuthMiddleware(secret, logger))
api.Use(rbac.PermissionMiddleware(store, logger, "clients:create"))
```

### Documentation
- ✅ `packages/go/README.md` - Shared packages guide
- ✅ `MONOREPO-RESTRUCTURE.md` - Complete migration doc
- ✅ Usage examples and best practices
- ✅ Troubleshooting guide

---

## Phase 4: Client-Specific Database Schema ✅ COMPLETED

### What Was Implemented

#### 1. Complete Client Database Schema
- ✅ Created 8 tables for tenant-specific data
- ✅ Implemented 5 enum types for type safety
- ✅ Added 20+ indexes for performance
- ✅ Created automated triggers for timestamps
- ✅ Comprehensive audit trail with activity_log

#### 2. Tables Created
- **audits** - Framework assignments with due dates
- **questions** - Questionnaire items from frameworks
- **question_assignments** - Delegation to stakeholders
- **submissions** - Client answers with versioning
- **evidence** - File uploads with MinIO paths
- **comments** - Discussion threads (internal/external)
- **reports** - Generated audit reports (signed/unsigned)
- **activity_log** - Complete activity tracking

#### 3. Type-Safe Query Layer (sqlc)
- ✅ Generated `clientdb` package separate from main `db`
- ✅ 50+ type-safe queries across all entities
- ✅ Support for bulk operations
- ✅ Complex queries for progress tracking

#### 4. Automatic Migration System
- ✅ Client migration runner implemented
- ✅ Integrated with provisioning flow
- ✅ Automatic schema deployment on new client creation
- ✅ Rollback support and version tracking

### Files Created
```
services/tenant-service/
├── db/
│   ├── client-migrations/
│   │   ├── 000001_init_client_schema.up.sql
│   │   └── 000001_init_client_schema.down.sql
│   └── client-queries/
│       ├── audits.sql
│       ├── questions.sql
│       ├── submissions.sql
│       ├── evidence.sql
│       ├── question_assignments.sql
│       ├── comments.sql
│       ├── reports.sql
│       └── activity_log.sql
├── internal/
│   ├── clientdb/           # Generated by sqlc
│   └── migrations/
│       └── client_migrations.go
└── sqlc.yaml              # Updated with client DB config
```

### Key Features
- **Data Isolation**: Each client has completely isolated database
- **Versioning**: Submission versioning for resubmissions
- **Soft Deletes**: Evidence files use soft delete
- **Audit Trail**: Complete activity logging
- **Flexible Questions**: Support for yes/no, text, multiple choice

---

## Phase 5: Client Onboarding Flow Enhancement ✅ COMPLETED

### What Was Implemented

#### 1. Client Store Manager
- ✅ Dynamic connection pooling for client databases
- ✅ Automatic credential decryption
- ✅ Connection caching for performance
- ✅ Transaction support for client operations
- ✅ Graceful connection cleanup

#### 2. Framework Service
- ✅ Template-based question management
- ✅ JSON framework templates
- ✅ Automatic question population
- ✅ Support for multiple question types
- ✅ Bulk question creation

#### 3. Framework Templates Created
- ✅ **NSE Template**: 24 questions across 6 sections
  - Information Security Policy
  - Access Control
  - Network Security
  - Data Protection
  - Incident Management
  - Business Continuity
  
- ✅ **BSE Template**: 11 questions across 5 sections
  - Information Security Governance
  - Risk Management
  - Physical and Environmental Security
  - System and Network Security
  - Data Backup and Recovery
  
- ✅ **NCDEX Template**: 11 questions across 5 sections
  - Compliance Framework
  - Trading System Security
  - Operational Risk Management
  - Data Privacy and Protection
  - Audit and Reporting

#### 4. Complete Onboarding Flow
```
Create Client Request
    ↓
Create Client Record (tenant_db)
    ↓
Create Isolated Database
    ↓
Create Database User + Secure Password
    ↓
Grant Database Privileges
    ↓
Run Client Schema Migrations
    ↓
Create MinIO Bucket
    ↓
Encrypt & Store Credentials
    ↓
Assign Frameworks to Client
    ↓
For Each Framework:
  - Load Template
  - Create Audit Assignment
  - Populate Questions
  - Set Due Date
    ↓
Client Ready for Use
```

### Files Created
```
services/tenant-service/
├── internal/
│   ├── clientstore/
│   │   └── store.go          # Client database manager
│   └── framework/
│       └── service.go        # Framework & question service
├── templates/
│   └── frameworks/
│       ├── nse-template.json
│       ├── bse-template.json
│       └── ncdex-template.json
└── internal/handler/
    ├── handler.go            # Updated dependencies
    └── client.go             # Enhanced provisioning
```

### Key Improvements
- **Automated Setup**: Complete client environment in one API call
- **Template-Based**: Easy to add new frameworks via JSON
- **Type-Safe**: All operations compile-time validated
- **Scalable**: Connection pooling and caching
- **Reliable**: Transaction-based provisioning

### API Example
```bash
POST /api/clients
{
  "name": "Bagadia Capital",
  "poc_email": "compliance@bagadia.com",
  "frameworks": ["<nse-id>", "<bse-id>"],
  "due_date": "2025-12-31"
}
```

**Result**: Client created with isolated DB, 35 questions populated, ready for audit submission.

---

## Next Steps (Phase 6: Questionnaire Management)

### To Be Implemented
1. **Framework CRUD APIs**
   - List all frameworks
   - Create custom frameworks
   - Update framework templates
   - Delete frameworks

2. **Question Management**
   - View questions by audit
   - Edit individual questions
   - Reorder questions
   - Add/remove questions

3. **Audit Management**
   - List client audits
   - View audit progress
   - Update due dates
   - Assign Client POC

4. **Submission APIs**
   - Create/update submissions
   - Submit for review
   - View submission history
   - Resubmit after rejection

---

## How to Run

### Prerequisites
```bash
# Ensure Docker services are running
docker-compose up -d postgres minio rabbitmq

# Install Go tools
make install-tools
```

### Run Migrations
```bash
make migrate-up
```

### Start Service
```bash
# Development (with hot reload)
make dev

# Or build and run
make build
./bin/tenant-service
```

### Test Endpoints
```bash
# Health check
curl http://localhost:8081/health

# List clients
curl http://localhost:8081/api/clients

# View API docs
open http://localhost:8081/swagger/index.html
```

---

## Architecture Decisions

1. **Separate Database Per Tenant**: Each client gets isolated PostgreSQL database for maximum data security
2. **Encrypted Credentials**: DB passwords encrypted with AES-256-GCM before storage
3. **Type-Safe SQL**: Using sqlc for compile-time SQL validation
4. **Structured Logging**: zap for high-performance structured logging
5. **Configuration Management**: Viper for flexible config with env overrides
6. **API Documentation**: Swagger/OpenAPI for auto-generated docs

---

## Known Limitations (To Address in Future Phases)

1. No authentication yet - all endpoints are open
2. No authorization checks - RBAC middleware not implemented
3. Client provisioning doesn't run tenant DB migrations yet
4. No email notifications on client creation
5. Framework assignment not fully implemented
6. No frontend integration yet

---

**Last Updated:** November 6, 2025
**Status:** Phase 1 Complete ✅
