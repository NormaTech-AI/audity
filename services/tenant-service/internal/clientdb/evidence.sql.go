// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: evidence.sql

package clientdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateEvidence = `-- name: CreateEvidence :one
INSERT INTO evidence (
    submission_id,
    file_name,
    file_path,
    file_size,
    file_type,
    uploaded_by,
    description
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, submission_id, file_name, file_path, file_size, file_type, uploaded_by, uploaded_at, description, is_deleted, deleted_at, deleted_by
`

type CreateEvidenceParams struct {
	SubmissionID uuid.UUID `json:"submission_id"`
	FileName     string    `json:"file_name"`
	FilePath     string    `json:"file_path"`
	FileSize     int64     `json:"file_size"`
	FileType     *string   `json:"file_type"`
	UploadedBy   uuid.UUID `json:"uploaded_by"`
	Description  *string   `json:"description"`
}

func (q *Queries) CreateEvidence(ctx context.Context, arg CreateEvidenceParams) (Evidence, error) {
	row := q.db.QueryRow(ctx, CreateEvidence,
		arg.SubmissionID,
		arg.FileName,
		arg.FilePath,
		arg.FileSize,
		arg.FileType,
		arg.UploadedBy,
		arg.Description,
	)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Description,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const GetEvidenceByID = `-- name: GetEvidenceByID :one
SELECT id, submission_id, file_name, file_path, file_size, file_type, uploaded_by, uploaded_at, description, is_deleted, deleted_at, deleted_by FROM evidence
WHERE id = $1 AND is_deleted = false
`

func (q *Queries) GetEvidenceByID(ctx context.Context, id uuid.UUID) (Evidence, error) {
	row := q.db.QueryRow(ctx, GetEvidenceByID, id)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Description,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const GetEvidenceStats = `-- name: GetEvidenceStats :one
SELECT 
    COUNT(*) as total_files,
    SUM(file_size) as total_size,
    COUNT(DISTINCT submission_id) as submissions_with_evidence
FROM evidence
WHERE is_deleted = false
`

type GetEvidenceStatsRow struct {
	TotalFiles              int64 `json:"total_files"`
	TotalSize               int64 `json:"total_size"`
	SubmissionsWithEvidence int64 `json:"submissions_with_evidence"`
}

func (q *Queries) GetEvidenceStats(ctx context.Context) (GetEvidenceStatsRow, error) {
	row := q.db.QueryRow(ctx, GetEvidenceStats)
	var i GetEvidenceStatsRow
	err := row.Scan(&i.TotalFiles, &i.TotalSize, &i.SubmissionsWithEvidence)
	return i, err
}

const HardDeleteEvidence = `-- name: HardDeleteEvidence :exec
DELETE FROM evidence
WHERE id = $1
`

func (q *Queries) HardDeleteEvidence(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, HardDeleteEvidence, id)
	return err
}

const ListEvidenceBySubmission = `-- name: ListEvidenceBySubmission :many
SELECT id, submission_id, file_name, file_path, file_size, file_type, uploaded_by, uploaded_at, description, is_deleted, deleted_at, deleted_by FROM evidence
WHERE submission_id = $1 AND is_deleted = false
ORDER BY uploaded_at DESC
`

func (q *Queries) ListEvidenceBySubmission(ctx context.Context, submissionID uuid.UUID) ([]Evidence, error) {
	rows, err := q.db.Query(ctx, ListEvidenceBySubmission, submissionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Evidence{}
	for rows.Next() {
		var i Evidence
		if err := rows.Scan(
			&i.ID,
			&i.SubmissionID,
			&i.FileName,
			&i.FilePath,
			&i.FileSize,
			&i.FileType,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Description,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListEvidenceByUser = `-- name: ListEvidenceByUser :many
SELECT e.id, e.submission_id, e.file_name, e.file_path, e.file_size, e.file_type, e.uploaded_by, e.uploaded_at, e.description, e.is_deleted, e.deleted_at, e.deleted_by, s.question_id
FROM evidence e
JOIN submissions s ON s.id = e.submission_id
WHERE e.uploaded_by = $1 AND e.is_deleted = false
ORDER BY e.uploaded_at DESC
`

type ListEvidenceByUserRow struct {
	ID           uuid.UUID          `json:"id"`
	SubmissionID uuid.UUID          `json:"submission_id"`
	FileName     string             `json:"file_name"`
	FilePath     string             `json:"file_path"`
	FileSize     int64              `json:"file_size"`
	FileType     *string            `json:"file_type"`
	UploadedBy   uuid.UUID          `json:"uploaded_by"`
	UploadedAt   pgtype.Timestamptz `json:"uploaded_at"`
	Description  *string            `json:"description"`
	IsDeleted    bool               `json:"is_deleted"`
	DeletedAt    pgtype.Timestamptz `json:"deleted_at"`
	DeletedBy    pgtype.UUID        `json:"deleted_by"`
	QuestionID   uuid.UUID          `json:"question_id"`
}

func (q *Queries) ListEvidenceByUser(ctx context.Context, uploadedBy uuid.UUID) ([]ListEvidenceByUserRow, error) {
	rows, err := q.db.Query(ctx, ListEvidenceByUser, uploadedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEvidenceByUserRow{}
	for rows.Next() {
		var i ListEvidenceByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.SubmissionID,
			&i.FileName,
			&i.FilePath,
			&i.FileSize,
			&i.FileType,
			&i.UploadedBy,
			&i.UploadedAt,
			&i.Description,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.DeletedBy,
			&i.QuestionID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SoftDeleteEvidence = `-- name: SoftDeleteEvidence :one
UPDATE evidence
SET 
    is_deleted = true,
    deleted_at = NOW(),
    deleted_by = $2
WHERE id = $1
RETURNING id, submission_id, file_name, file_path, file_size, file_type, uploaded_by, uploaded_at, description, is_deleted, deleted_at, deleted_by
`

type SoftDeleteEvidenceParams struct {
	ID        uuid.UUID   `json:"id"`
	DeletedBy pgtype.UUID `json:"deleted_by"`
}

func (q *Queries) SoftDeleteEvidence(ctx context.Context, arg SoftDeleteEvidenceParams) (Evidence, error) {
	row := q.db.QueryRow(ctx, SoftDeleteEvidence, arg.ID, arg.DeletedBy)
	var i Evidence
	err := row.Scan(
		&i.ID,
		&i.SubmissionID,
		&i.FileName,
		&i.FilePath,
		&i.FileSize,
		&i.FileType,
		&i.UploadedBy,
		&i.UploadedAt,
		&i.Description,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
