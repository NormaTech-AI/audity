// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: framework_questions.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

type BulkCreateFrameworkQuestionsParams struct {
	FrameworkID        uuid.UUID `json:"framework_id"`
	ControlID          string    `json:"control_id"`
	QuestionText       string    `json:"question_text"`
	HelpText           *string   `json:"help_text"`
	AcceptableEvidence []string  `json:"acceptable_evidence"`
}

const CountFrameworkQuestions = `-- name: CountFrameworkQuestions :one
SELECT COUNT(*) FROM framework_questions
WHERE framework_id = $1
`

func (q *Queries) CountFrameworkQuestions(ctx context.Context, frameworkID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, CountFrameworkQuestions, frameworkID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateFrameworkQuestion = `-- name: CreateFrameworkQuestion :one
INSERT INTO framework_questions (
    framework_id,
    section_title,
    control_id,
    question_text,
    help_text,
    acceptable_evidence
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING question_id, framework_id, control_id, question_text, help_text, acceptable_evidence, created_at, updated_at, section_title
`

type CreateFrameworkQuestionParams struct {
	FrameworkID        uuid.UUID `json:"framework_id"`
	SectionTitle       *string   `json:"section_title"`
	ControlID          string    `json:"control_id"`
	QuestionText       string    `json:"question_text"`
	HelpText           *string   `json:"help_text"`
	AcceptableEvidence []string  `json:"acceptable_evidence"`
}

func (q *Queries) CreateFrameworkQuestion(ctx context.Context, arg CreateFrameworkQuestionParams) (FrameworkQuestion, error) {
	row := q.db.QueryRow(ctx, CreateFrameworkQuestion,
		arg.FrameworkID,
		arg.SectionTitle,
		arg.ControlID,
		arg.QuestionText,
		arg.HelpText,
		arg.AcceptableEvidence,
	)
	var i FrameworkQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.FrameworkID,
		&i.ControlID,
		&i.QuestionText,
		&i.HelpText,
		&i.AcceptableEvidence,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SectionTitle,
	)
	return i, err
}

const DeleteFrameworkQuestion = `-- name: DeleteFrameworkQuestion :exec
DELETE FROM framework_questions
WHERE question_id = $1
`

func (q *Queries) DeleteFrameworkQuestion(ctx context.Context, questionID uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteFrameworkQuestion, questionID)
	return err
}

const DeleteFrameworkQuestionsByFrameworkId = `-- name: DeleteFrameworkQuestionsByFrameworkId :exec
DELETE FROM framework_questions
WHERE framework_id = $1
`

func (q *Queries) DeleteFrameworkQuestionsByFrameworkId(ctx context.Context, frameworkID uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteFrameworkQuestionsByFrameworkId, frameworkID)
	return err
}

const GetFrameworkQuestion = `-- name: GetFrameworkQuestion :one
SELECT question_id, framework_id, control_id, question_text, help_text, acceptable_evidence, created_at, updated_at, section_title FROM framework_questions
WHERE question_id = $1 LIMIT 1
`

func (q *Queries) GetFrameworkQuestion(ctx context.Context, questionID uuid.UUID) (FrameworkQuestion, error) {
	row := q.db.QueryRow(ctx, GetFrameworkQuestion, questionID)
	var i FrameworkQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.FrameworkID,
		&i.ControlID,
		&i.QuestionText,
		&i.HelpText,
		&i.AcceptableEvidence,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SectionTitle,
	)
	return i, err
}

const GetFrameworkWithQuestions = `-- name: GetFrameworkWithQuestions :many
SELECT 
    f.id as framework_id,
    f.name as framework_name,
    f.description as framework_description,
    f.version as framework_version,
    fq.question_id,
    fq.control_id,
    fq.question_text,
    fq.help_text,
    fq.acceptable_evidence
FROM compliance_frameworks f
LEFT JOIN framework_questions fq ON f.id = fq.framework_id
WHERE f.id = $1
ORDER BY fq.control_id
`

type GetFrameworkWithQuestionsRow struct {
	FrameworkID          uuid.UUID   `json:"framework_id"`
	FrameworkName        string      `json:"framework_name"`
	FrameworkDescription *string     `json:"framework_description"`
	FrameworkVersion     *string     `json:"framework_version"`
	QuestionID           pgtype.UUID `json:"question_id"`
	ControlID            *string     `json:"control_id"`
	QuestionText         *string     `json:"question_text"`
	HelpText             *string     `json:"help_text"`
	AcceptableEvidence   []string    `json:"acceptable_evidence"`
}

func (q *Queries) GetFrameworkWithQuestions(ctx context.Context, id uuid.UUID) ([]GetFrameworkWithQuestionsRow, error) {
	rows, err := q.db.Query(ctx, GetFrameworkWithQuestions, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFrameworkWithQuestionsRow{}
	for rows.Next() {
		var i GetFrameworkWithQuestionsRow
		if err := rows.Scan(
			&i.FrameworkID,
			&i.FrameworkName,
			&i.FrameworkDescription,
			&i.FrameworkVersion,
			&i.QuestionID,
			&i.ControlID,
			&i.QuestionText,
			&i.HelpText,
			&i.AcceptableEvidence,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListFrameworkQuestions = `-- name: ListFrameworkQuestions :many
SELECT question_id, framework_id, control_id, question_text, help_text, acceptable_evidence, created_at, updated_at, section_title FROM framework_questions
WHERE framework_id = $1
ORDER BY control_id
`

func (q *Queries) ListFrameworkQuestions(ctx context.Context, frameworkID uuid.UUID) ([]FrameworkQuestion, error) {
	rows, err := q.db.Query(ctx, ListFrameworkQuestions, frameworkID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FrameworkQuestion{}
	for rows.Next() {
		var i FrameworkQuestion
		if err := rows.Scan(
			&i.QuestionID,
			&i.FrameworkID,
			&i.ControlID,
			&i.QuestionText,
			&i.HelpText,
			&i.AcceptableEvidence,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SectionTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateFrameworkQuestion = `-- name: UpdateFrameworkQuestion :one
UPDATE framework_questions
SET 
    section_title = $2,
    control_id = $3,
    question_text = $4,
    help_text = $5,
    acceptable_evidence = $6
WHERE question_id = $1
RETURNING question_id, framework_id, control_id, question_text, help_text, acceptable_evidence, created_at, updated_at, section_title
`

type UpdateFrameworkQuestionParams struct {
	QuestionID         uuid.UUID `json:"question_id"`
	SectionTitle       *string   `json:"section_title"`
	ControlID          string    `json:"control_id"`
	QuestionText       string    `json:"question_text"`
	HelpText           *string   `json:"help_text"`
	AcceptableEvidence []string  `json:"acceptable_evidence"`
}

func (q *Queries) UpdateFrameworkQuestion(ctx context.Context, arg UpdateFrameworkQuestionParams) (FrameworkQuestion, error) {
	row := q.db.QueryRow(ctx, UpdateFrameworkQuestion,
		arg.QuestionID,
		arg.SectionTitle,
		arg.ControlID,
		arg.QuestionText,
		arg.HelpText,
		arg.AcceptableEvidence,
	)
	var i FrameworkQuestion
	err := row.Scan(
		&i.QuestionID,
		&i.FrameworkID,
		&i.ControlID,
		&i.QuestionText,
		&i.HelpText,
		&i.AcceptableEvidence,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SectionTitle,
	)
	return i, err
}
