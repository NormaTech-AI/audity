// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: submissions.sql

package clientdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const ApproveSubmission = `-- name: ApproveSubmission :one
UPDATE submissions
SET 
    status = 'approved',
    reviewed_by = $2,
    reviewed_at = NOW(),
    review_notes = $3
WHERE id = $1
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type ApproveSubmissionParams struct {
	ID          uuid.UUID   `json:"id"`
	ReviewedBy  pgtype.UUID `json:"reviewed_by"`
	ReviewNotes *string     `json:"review_notes"`
}

func (q *Queries) ApproveSubmission(ctx context.Context, arg ApproveSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, ApproveSubmission, arg.ID, arg.ReviewedBy, arg.ReviewNotes)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const CreateSubmission = `-- name: CreateSubmission :one
INSERT INTO submissions (
    question_id,
    submitted_by,
    answer_value,
    answer_text,
    explanation,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type CreateSubmissionParams struct {
	QuestionID  uuid.UUID            `json:"question_id"`
	SubmittedBy uuid.UUID            `json:"submitted_by"`
	AnswerValue NullAnswerValueEnum  `json:"answer_value"`
	AnswerText  *string              `json:"answer_text"`
	Explanation string               `json:"explanation"`
	Status      SubmissionStatusEnum `json:"status"`
}

func (q *Queries) CreateSubmission(ctx context.Context, arg CreateSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, CreateSubmission,
		arg.QuestionID,
		arg.SubmittedBy,
		arg.AnswerValue,
		arg.AnswerText,
		arg.Explanation,
		arg.Status,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubmissionByID = `-- name: GetSubmissionByID :one
SELECT id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at FROM submissions
WHERE id = $1
`

func (q *Queries) GetSubmissionByID(ctx context.Context, id uuid.UUID) (Submission, error) {
	row := q.db.QueryRow(ctx, GetSubmissionByID, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubmissionByQuestionID = `-- name: GetSubmissionByQuestionID :one
SELECT id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at FROM submissions
WHERE question_id = $1
ORDER BY version DESC
LIMIT 1
`

func (q *Queries) GetSubmissionByQuestionID(ctx context.Context, questionID uuid.UUID) (Submission, error) {
	row := q.db.QueryRow(ctx, GetSubmissionByQuestionID, questionID)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetSubmissionWithEvidence = `-- name: GetSubmissionWithEvidence :one
SELECT 
    s.id, s.question_id, s.submitted_by, s.answer_value, s.answer_text, s.explanation, s.status, s.submitted_at, s.reviewed_by, s.reviewed_at, s.review_notes, s.rejection_reason, s.version, s.created_at, s.updated_at,
    q.question_text,
    q.section,
    COUNT(e.id) as evidence_count
FROM submissions s
JOIN questions q ON q.id = s.question_id
LEFT JOIN evidence e ON e.submission_id = s.id AND e.is_deleted = false
WHERE s.id = $1
GROUP BY s.id, q.id
`

type GetSubmissionWithEvidenceRow struct {
	ID              uuid.UUID            `json:"id"`
	QuestionID      uuid.UUID            `json:"question_id"`
	SubmittedBy     uuid.UUID            `json:"submitted_by"`
	AnswerValue     NullAnswerValueEnum  `json:"answer_value"`
	AnswerText      *string              `json:"answer_text"`
	Explanation     string               `json:"explanation"`
	Status          SubmissionStatusEnum `json:"status"`
	SubmittedAt     pgtype.Timestamptz   `json:"submitted_at"`
	ReviewedBy      pgtype.UUID          `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `json:"reviewed_at"`
	ReviewNotes     *string              `json:"review_notes"`
	RejectionReason *string              `json:"rejection_reason"`
	Version         int32                `json:"version"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
	QuestionText    string               `json:"question_text"`
	Section         string               `json:"section"`
	EvidenceCount   int64                `json:"evidence_count"`
}

func (q *Queries) GetSubmissionWithEvidence(ctx context.Context, id uuid.UUID) (GetSubmissionWithEvidenceRow, error) {
	row := q.db.QueryRow(ctx, GetSubmissionWithEvidence, id)
	var i GetSubmissionWithEvidenceRow
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.QuestionText,
		&i.Section,
		&i.EvidenceCount,
	)
	return i, err
}

const ListPendingReviews = `-- name: ListPendingReviews :many
SELECT 
    s.id, s.question_id, s.submitted_by, s.answer_value, s.answer_text, s.explanation, s.status, s.submitted_at, s.reviewed_by, s.reviewed_at, s.review_notes, s.rejection_reason, s.version, s.created_at, s.updated_at,
    q.question_text,
    q.section,
    q.audit_id,
    a.framework_name
FROM submissions s
JOIN questions q ON q.id = s.question_id
JOIN audits a ON a.id = q.audit_id
WHERE s.status = 'submitted'
ORDER BY s.submitted_at ASC
`

type ListPendingReviewsRow struct {
	ID              uuid.UUID            `json:"id"`
	QuestionID      uuid.UUID            `json:"question_id"`
	SubmittedBy     uuid.UUID            `json:"submitted_by"`
	AnswerValue     NullAnswerValueEnum  `json:"answer_value"`
	AnswerText      *string              `json:"answer_text"`
	Explanation     string               `json:"explanation"`
	Status          SubmissionStatusEnum `json:"status"`
	SubmittedAt     pgtype.Timestamptz   `json:"submitted_at"`
	ReviewedBy      pgtype.UUID          `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `json:"reviewed_at"`
	ReviewNotes     *string              `json:"review_notes"`
	RejectionReason *string              `json:"rejection_reason"`
	Version         int32                `json:"version"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
	QuestionText    string               `json:"question_text"`
	Section         string               `json:"section"`
	AuditID         uuid.UUID            `json:"audit_id"`
	FrameworkName   string               `json:"framework_name"`
}

func (q *Queries) ListPendingReviews(ctx context.Context) ([]ListPendingReviewsRow, error) {
	rows, err := q.db.Query(ctx, ListPendingReviews)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPendingReviewsRow{}
	for rows.Next() {
		var i ListPendingReviewsRow
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.SubmittedBy,
			&i.AnswerValue,
			&i.AnswerText,
			&i.Explanation,
			&i.Status,
			&i.SubmittedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.RejectionReason,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestionText,
			&i.Section,
			&i.AuditID,
			&i.FrameworkName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubmissionsByStatus = `-- name: ListSubmissionsByStatus :many
SELECT s.id, s.question_id, s.submitted_by, s.answer_value, s.answer_text, s.explanation, s.status, s.submitted_at, s.reviewed_by, s.reviewed_at, s.review_notes, s.rejection_reason, s.version, s.created_at, s.updated_at, q.question_text, q.section, q.audit_id
FROM submissions s
JOIN questions q ON q.id = s.question_id
WHERE s.status = $1
ORDER BY s.submitted_at DESC
`

type ListSubmissionsByStatusRow struct {
	ID              uuid.UUID            `json:"id"`
	QuestionID      uuid.UUID            `json:"question_id"`
	SubmittedBy     uuid.UUID            `json:"submitted_by"`
	AnswerValue     NullAnswerValueEnum  `json:"answer_value"`
	AnswerText      *string              `json:"answer_text"`
	Explanation     string               `json:"explanation"`
	Status          SubmissionStatusEnum `json:"status"`
	SubmittedAt     pgtype.Timestamptz   `json:"submitted_at"`
	ReviewedBy      pgtype.UUID          `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `json:"reviewed_at"`
	ReviewNotes     *string              `json:"review_notes"`
	RejectionReason *string              `json:"rejection_reason"`
	Version         int32                `json:"version"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
	QuestionText    string               `json:"question_text"`
	Section         string               `json:"section"`
	AuditID         uuid.UUID            `json:"audit_id"`
}

func (q *Queries) ListSubmissionsByStatus(ctx context.Context, status SubmissionStatusEnum) ([]ListSubmissionsByStatusRow, error) {
	rows, err := q.db.Query(ctx, ListSubmissionsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubmissionsByStatusRow{}
	for rows.Next() {
		var i ListSubmissionsByStatusRow
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.SubmittedBy,
			&i.AnswerValue,
			&i.AnswerText,
			&i.Explanation,
			&i.Status,
			&i.SubmittedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.RejectionReason,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestionText,
			&i.Section,
			&i.AuditID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListSubmissionsByUser = `-- name: ListSubmissionsByUser :many
SELECT s.id, s.question_id, s.submitted_by, s.answer_value, s.answer_text, s.explanation, s.status, s.submitted_at, s.reviewed_by, s.reviewed_at, s.review_notes, s.rejection_reason, s.version, s.created_at, s.updated_at, q.question_text, q.section
FROM submissions s
JOIN questions q ON q.id = s.question_id
WHERE s.submitted_by = $1
ORDER BY s.submitted_at DESC
`

type ListSubmissionsByUserRow struct {
	ID              uuid.UUID            `json:"id"`
	QuestionID      uuid.UUID            `json:"question_id"`
	SubmittedBy     uuid.UUID            `json:"submitted_by"`
	AnswerValue     NullAnswerValueEnum  `json:"answer_value"`
	AnswerText      *string              `json:"answer_text"`
	Explanation     string               `json:"explanation"`
	Status          SubmissionStatusEnum `json:"status"`
	SubmittedAt     pgtype.Timestamptz   `json:"submitted_at"`
	ReviewedBy      pgtype.UUID          `json:"reviewed_by"`
	ReviewedAt      pgtype.Timestamptz   `json:"reviewed_at"`
	ReviewNotes     *string              `json:"review_notes"`
	RejectionReason *string              `json:"rejection_reason"`
	Version         int32                `json:"version"`
	CreatedAt       pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz   `json:"updated_at"`
	QuestionText    string               `json:"question_text"`
	Section         string               `json:"section"`
}

func (q *Queries) ListSubmissionsByUser(ctx context.Context, submittedBy uuid.UUID) ([]ListSubmissionsByUserRow, error) {
	rows, err := q.db.Query(ctx, ListSubmissionsByUser, submittedBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSubmissionsByUserRow{}
	for rows.Next() {
		var i ListSubmissionsByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.QuestionID,
			&i.SubmittedBy,
			&i.AnswerValue,
			&i.AnswerText,
			&i.Explanation,
			&i.Status,
			&i.SubmittedAt,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.ReviewNotes,
			&i.RejectionReason,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestionText,
			&i.Section,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ReferSubmission = `-- name: ReferSubmission :one
UPDATE submissions
SET 
    status = 'referred',
    reviewed_by = $2,
    reviewed_at = NOW(),
    review_notes = $3
WHERE id = $1
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type ReferSubmissionParams struct {
	ID          uuid.UUID   `json:"id"`
	ReviewedBy  pgtype.UUID `json:"reviewed_by"`
	ReviewNotes *string     `json:"review_notes"`
}

func (q *Queries) ReferSubmission(ctx context.Context, arg ReferSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, ReferSubmission, arg.ID, arg.ReviewedBy, arg.ReviewNotes)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const RejectSubmission = `-- name: RejectSubmission :one
UPDATE submissions
SET 
    status = 'rejected',
    reviewed_by = $2,
    reviewed_at = NOW(),
    rejection_reason = $3,
    review_notes = $4
WHERE id = $1
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type RejectSubmissionParams struct {
	ID              uuid.UUID   `json:"id"`
	ReviewedBy      pgtype.UUID `json:"reviewed_by"`
	RejectionReason *string     `json:"rejection_reason"`
	ReviewNotes     *string     `json:"review_notes"`
}

func (q *Queries) RejectSubmission(ctx context.Context, arg RejectSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, RejectSubmission,
		arg.ID,
		arg.ReviewedBy,
		arg.RejectionReason,
		arg.ReviewNotes,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ResubmitSubmission = `-- name: ResubmitSubmission :one
INSERT INTO submissions (
    question_id,
    submitted_by,
    answer_value,
    answer_text,
    explanation,
    status,
    version
) VALUES (
    $1, $2, $3, $4, $5, 'submitted',
    (SELECT COALESCE(MAX(version), 0) + 1 FROM submissions WHERE question_id = $1)
)
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type ResubmitSubmissionParams struct {
	QuestionID  uuid.UUID           `json:"question_id"`
	SubmittedBy uuid.UUID           `json:"submitted_by"`
	AnswerValue NullAnswerValueEnum `json:"answer_value"`
	AnswerText  *string             `json:"answer_text"`
	Explanation string              `json:"explanation"`
}

func (q *Queries) ResubmitSubmission(ctx context.Context, arg ResubmitSubmissionParams) (Submission, error) {
	row := q.db.QueryRow(ctx, ResubmitSubmission,
		arg.QuestionID,
		arg.SubmittedBy,
		arg.AnswerValue,
		arg.AnswerText,
		arg.Explanation,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const SubmitSubmission = `-- name: SubmitSubmission :one
UPDATE submissions
SET 
    status = 'submitted',
    submitted_at = NOW()
WHERE id = $1
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

func (q *Queries) SubmitSubmission(ctx context.Context, id uuid.UUID) (Submission, error) {
	row := q.db.QueryRow(ctx, SubmitSubmission, id)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateSubmissionAnswer = `-- name: UpdateSubmissionAnswer :one
UPDATE submissions
SET 
    answer_value = $2,
    answer_text = $3,
    explanation = $4,
    status = 'in_progress'
WHERE id = $1
RETURNING id, question_id, submitted_by, answer_value, answer_text, explanation, status, submitted_at, reviewed_by, reviewed_at, review_notes, rejection_reason, version, created_at, updated_at
`

type UpdateSubmissionAnswerParams struct {
	ID          uuid.UUID           `json:"id"`
	AnswerValue NullAnswerValueEnum `json:"answer_value"`
	AnswerText  *string             `json:"answer_text"`
	Explanation string              `json:"explanation"`
}

func (q *Queries) UpdateSubmissionAnswer(ctx context.Context, arg UpdateSubmissionAnswerParams) (Submission, error) {
	row := q.db.QueryRow(ctx, UpdateSubmissionAnswer,
		arg.ID,
		arg.AnswerValue,
		arg.AnswerText,
		arg.Explanation,
	)
	var i Submission
	err := row.Scan(
		&i.ID,
		&i.QuestionID,
		&i.SubmittedBy,
		&i.AnswerValue,
		&i.AnswerText,
		&i.Explanation,
		&i.Status,
		&i.SubmittedAt,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.ReviewNotes,
		&i.RejectionReason,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
