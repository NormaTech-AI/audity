// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audits.sql

package clientdb

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const CreateAudit = `-- name: CreateAudit :one
INSERT INTO audits (
    framework_id,
    framework_name,
    assigned_by,
    assigned_to,
    due_date,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at
`

type CreateAuditParams struct {
	FrameworkID   uuid.UUID       `json:"framework_id"`
	FrameworkName string          `json:"framework_name"`
	AssignedBy    uuid.UUID       `json:"assigned_by"`
	AssignedTo    pgtype.UUID     `json:"assigned_to"`
	DueDate       pgtype.Date     `json:"due_date"`
	Status        AuditStatusEnum `json:"status"`
}

func (q *Queries) CreateAudit(ctx context.Context, arg CreateAuditParams) (Audit, error) {
	row := q.db.QueryRow(ctx, CreateAudit,
		arg.FrameworkID,
		arg.FrameworkName,
		arg.AssignedBy,
		arg.AssignedTo,
		arg.DueDate,
		arg.Status,
	)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedTo,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const DeleteAudit = `-- name: DeleteAudit :exec
DELETE FROM audits
WHERE id = $1
`

func (q *Queries) DeleteAudit(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteAudit, id)
	return err
}

const GetAuditByID = `-- name: GetAuditByID :one
SELECT id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at FROM audits
WHERE id = $1
`

func (q *Queries) GetAuditByID(ctx context.Context, id uuid.UUID) (Audit, error) {
	row := q.db.QueryRow(ctx, GetAuditByID, id)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedTo,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const GetAuditProgress = `-- name: GetAuditProgress :one
SELECT 
    a.id,
    a.framework_name,
    a.status,
    a.due_date,
    COUNT(q.id) as total_questions,
    COUNT(CASE WHEN s.status = 'approved' THEN 1 END) as approved_count,
    COUNT(CASE WHEN s.status = 'submitted' THEN 1 END) as submitted_count,
    COUNT(CASE WHEN s.status = 'rejected' THEN 1 END) as rejected_count
FROM audits a
LEFT JOIN questions q ON q.audit_id = a.id
LEFT JOIN submissions s ON s.question_id = q.id
WHERE a.id = $1
GROUP BY a.id
`

type GetAuditProgressRow struct {
	ID             uuid.UUID       `json:"id"`
	FrameworkName  string          `json:"framework_name"`
	Status         AuditStatusEnum `json:"status"`
	DueDate        pgtype.Date     `json:"due_date"`
	TotalQuestions int64           `json:"total_questions"`
	ApprovedCount  int64           `json:"approved_count"`
	SubmittedCount int64           `json:"submitted_count"`
	RejectedCount  int64           `json:"rejected_count"`
}

func (q *Queries) GetAuditProgress(ctx context.Context, id uuid.UUID) (GetAuditProgressRow, error) {
	row := q.db.QueryRow(ctx, GetAuditProgress, id)
	var i GetAuditProgressRow
	err := row.Scan(
		&i.ID,
		&i.FrameworkName,
		&i.Status,
		&i.DueDate,
		&i.TotalQuestions,
		&i.ApprovedCount,
		&i.SubmittedCount,
		&i.RejectedCount,
	)
	return i, err
}

const ListAudits = `-- name: ListAudits :many
SELECT id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at FROM audits
ORDER BY created_at DESC
`

func (q *Queries) ListAudits(ctx context.Context) ([]Audit, error) {
	rows, err := q.db.Query(ctx, ListAudits)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.FrameworkID,
			&i.FrameworkName,
			&i.AssignedBy,
			&i.AssignedTo,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAuditsByStatus = `-- name: ListAuditsByStatus :many
SELECT id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at FROM audits
WHERE status = $1
ORDER BY due_date ASC
`

func (q *Queries) ListAuditsByStatus(ctx context.Context, status AuditStatusEnum) ([]Audit, error) {
	rows, err := q.db.Query(ctx, ListAuditsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.FrameworkID,
			&i.FrameworkName,
			&i.AssignedBy,
			&i.AssignedTo,
			&i.DueDate,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateAuditAssignee = `-- name: UpdateAuditAssignee :one
UPDATE audits
SET assigned_to = $1
WHERE id = $2
RETURNING id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at
`

type UpdateAuditAssigneeParams struct {
	AssignedTo pgtype.UUID `json:"assigned_to"`
	ID         uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateAuditAssignee(ctx context.Context, arg UpdateAuditAssigneeParams) (Audit, error) {
	row := q.db.QueryRow(ctx, UpdateAuditAssignee, arg.AssignedTo, arg.ID)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedTo,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const UpdateAuditStatus = `-- name: UpdateAuditStatus :one
UPDATE audits
SET status = $1,
    completed_at = CASE WHEN $1 = 'completed' THEN NOW() ELSE completed_at END
WHERE id = $2
RETURNING id, framework_id, framework_name, assigned_by, assigned_to, due_date, status, created_at, updated_at, completed_at
`

type UpdateAuditStatusParams struct {
	Status AuditStatusEnum `json:"status"`
	ID     uuid.UUID       `json:"id"`
}

func (q *Queries) UpdateAuditStatus(ctx context.Context, arg UpdateAuditStatusParams) (Audit, error) {
	row := q.db.QueryRow(ctx, UpdateAuditStatus, arg.Status, arg.ID)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedTo,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
