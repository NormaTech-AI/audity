// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const CountClients = `-- name: CountClients :one
SELECT COUNT(*) FROM clients
`

func (q *Queries) CountClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, CountClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountClientsByStatus = `-- name: CountClientsByStatus :one
SELECT COUNT(*) FROM clients
WHERE status = $1
`

func (q *Queries) CountClientsByStatus(ctx context.Context, status NullClientStatusEnum) (int64, error) {
	row := q.db.QueryRow(ctx, CountClientsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CreateClient = `-- name: CreateClient :one
INSERT INTO clients (name, poc_email, status, email_domain)
VALUES ($1, $2, $3, $4)
RETURNING id, name, poc_email, status, created_at, updated_at, email_domain
`

type CreateClientParams struct {
	Name        string               `json:"name"`
	PocEmail    string               `json:"poc_email"`
	Status      NullClientStatusEnum `json:"status"`
	EmailDomain *string              `json:"email_domain"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (Client, error) {
	row := q.db.QueryRow(ctx, CreateClient,
		arg.Name,
		arg.PocEmail,
		arg.Status,
		arg.EmailDomain,
	)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PocEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailDomain,
	)
	return i, err
}

const DeleteClient = `-- name: DeleteClient :exec
DELETE FROM clients
WHERE id = $1
`

func (q *Queries) DeleteClient(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteClient, id)
	return err
}

const GetClient = `-- name: GetClient :one
SELECT id, name, poc_email, status, created_at, updated_at, email_domain FROM clients
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetClient(ctx context.Context, id uuid.UUID) (Client, error) {
	row := q.db.QueryRow(ctx, GetClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PocEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailDomain,
	)
	return i, err
}

const GetClientByEmail = `-- name: GetClientByEmail :one
SELECT id, name, poc_email, status, created_at, updated_at, email_domain FROM clients
WHERE poc_email = $1 LIMIT 1
`

func (q *Queries) GetClientByEmail(ctx context.Context, pocEmail string) (Client, error) {
	row := q.db.QueryRow(ctx, GetClientByEmail, pocEmail)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PocEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailDomain,
	)
	return i, err
}

const ListActiveClients = `-- name: ListActiveClients :many
SELECT id, name, poc_email, status, created_at, updated_at, email_domain FROM clients
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.Query(ctx, ListActiveClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PocEmail,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmailDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListClients = `-- name: ListClients :many
SELECT id, name, poc_email, status, created_at, updated_at, email_domain FROM clients
ORDER BY created_at DESC
`

func (q *Queries) ListClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.Query(ctx, ListClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PocEmail,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.EmailDomain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateClient = `-- name: UpdateClient :one
UPDATE clients
SET name = $2, poc_email = $3, status = $4, email_domain = $5
WHERE id = $1
RETURNING id, name, poc_email, status, created_at, updated_at, email_domain
`

type UpdateClientParams struct {
	ID          uuid.UUID            `json:"id"`
	Name        string               `json:"name"`
	PocEmail    string               `json:"poc_email"`
	Status      NullClientStatusEnum `json:"status"`
	EmailDomain *string              `json:"email_domain"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) (Client, error) {
	row := q.db.QueryRow(ctx, UpdateClient,
		arg.ID,
		arg.Name,
		arg.PocEmail,
		arg.Status,
		arg.EmailDomain,
	)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PocEmail,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.EmailDomain,
	)
	return i, err
}
