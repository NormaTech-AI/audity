// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: audit_cycles.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const AddClientToAuditCycle = `-- name: AddClientToAuditCycle :one
INSERT INTO audit_cycle_clients (audit_cycle_id, client_id)
VALUES ($1, $2)
RETURNING id, audit_cycle_id, client_id, created_at
`

type AddClientToAuditCycleParams struct {
	AuditCycleID uuid.UUID `json:"audit_cycle_id"`
	ClientID     uuid.UUID `json:"client_id"`
}

func (q *Queries) AddClientToAuditCycle(ctx context.Context, arg AddClientToAuditCycleParams) (AuditCycleClient, error) {
	row := q.db.QueryRow(ctx, AddClientToAuditCycle, arg.AuditCycleID, arg.ClientID)
	var i AuditCycleClient
	err := row.Scan(
		&i.ID,
		&i.AuditCycleID,
		&i.ClientID,
		&i.CreatedAt,
	)
	return i, err
}

const AssignFrameworkToAuditCycleClient = `-- name: AssignFrameworkToAuditCycleClient :one
INSERT INTO audit_cycle_frameworks (
    audit_cycle_client_id,
    framework_id,
    framework_name,
    assigned_by,
    due_date,
    status,
    auditor_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, audit_cycle_client_id, framework_id, framework_name, assigned_by, assigned_at, due_date, status, created_at, updated_at, auditor_id
`

type AssignFrameworkToAuditCycleClientParams struct {
	AuditCycleClientID uuid.UUID   `json:"audit_cycle_client_id"`
	FrameworkID        uuid.UUID   `json:"framework_id"`
	FrameworkName      string      `json:"framework_name"`
	AssignedBy         pgtype.UUID `json:"assigned_by"`
	DueDate            pgtype.Date `json:"due_date"`
	Status             *string     `json:"status"`
	AuditorID          pgtype.UUID `json:"auditor_id"`
}

func (q *Queries) AssignFrameworkToAuditCycleClient(ctx context.Context, arg AssignFrameworkToAuditCycleClientParams) (AuditCycleFramework, error) {
	row := q.db.QueryRow(ctx, AssignFrameworkToAuditCycleClient,
		arg.AuditCycleClientID,
		arg.FrameworkID,
		arg.FrameworkName,
		arg.AssignedBy,
		arg.DueDate,
		arg.Status,
		arg.AuditorID,
	)
	var i AuditCycleFramework
	err := row.Scan(
		&i.ID,
		&i.AuditCycleClientID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedAt,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditorID,
	)
	return i, err
}

const CreateAuditCycle = `-- name: CreateAuditCycle :one
INSERT INTO audit_cycles (name, description, start_date, end_date, created_by)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, start_date, end_date, status, created_by, created_at, updated_at
`

type CreateAuditCycleParams struct {
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	CreatedBy   pgtype.UUID `json:"created_by"`
}

func (q *Queries) CreateAuditCycle(ctx context.Context, arg CreateAuditCycleParams) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, CreateAuditCycle,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
		arg.CreatedBy,
	)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const DeleteAuditCycle = `-- name: DeleteAuditCycle :exec
DELETE FROM audit_cycles
WHERE id = $1
`

func (q *Queries) DeleteAuditCycle(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteAuditCycle, id)
	return err
}

const DeleteAuditCycleFramework = `-- name: DeleteAuditCycleFramework :exec
DELETE FROM audit_cycle_frameworks
WHERE id = $1
`

func (q *Queries) DeleteAuditCycleFramework(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, DeleteAuditCycleFramework, id)
	return err
}

const GetAuditCycle = `-- name: GetAuditCycle :one
SELECT id, name, description, start_date, end_date, status, created_by, created_at, updated_at FROM audit_cycles
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetAuditCycle(ctx context.Context, id uuid.UUID) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, GetAuditCycle, id)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const GetAuditCycleClients = `-- name: GetAuditCycleClients :many
SELECT 
    acc.id,
    acc.audit_cycle_id,
    acc.client_id,
    acc.created_at,
    c.name as client_name,
    c.poc_email,
    c.status as client_status
FROM audit_cycle_clients acc
JOIN clients c ON acc.client_id = c.id
WHERE acc.audit_cycle_id = $1
ORDER BY c.name ASC
`

type GetAuditCycleClientsRow struct {
	ID           uuid.UUID            `json:"id"`
	AuditCycleID uuid.UUID            `json:"audit_cycle_id"`
	ClientID     uuid.UUID            `json:"client_id"`
	CreatedAt    pgtype.Timestamptz   `json:"created_at"`
	ClientName   string               `json:"client_name"`
	PocEmail     string               `json:"poc_email"`
	ClientStatus NullClientStatusEnum `json:"client_status"`
}

func (q *Queries) GetAuditCycleClients(ctx context.Context, auditCycleID uuid.UUID) ([]GetAuditCycleClientsRow, error) {
	rows, err := q.db.Query(ctx, GetAuditCycleClients, auditCycleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditCycleClientsRow{}
	for rows.Next() {
		var i GetAuditCycleClientsRow
		if err := rows.Scan(
			&i.ID,
			&i.AuditCycleID,
			&i.ClientID,
			&i.CreatedAt,
			&i.ClientName,
			&i.PocEmail,
			&i.ClientStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditCycleFrameworks = `-- name: GetAuditCycleFrameworks :many
SELECT 
    acf.id,
    acf.audit_cycle_client_id,
    acf.framework_id,
    acf.framework_name,
    acf.assigned_by,
    acf.assigned_at,
    acf.due_date,
    acf.status,
    acf.auditor_id,
    acf.created_at,
    acf.updated_at,
    acc.client_id,
    c.name as client_name
FROM audit_cycle_frameworks acf
JOIN audit_cycle_clients acc ON acf.audit_cycle_client_id = acc.id
JOIN clients c ON acc.client_id = c.id
WHERE acc.audit_cycle_id = $1
ORDER BY c.name ASC, acf.framework_name ASC
`

type GetAuditCycleFrameworksRow struct {
	ID                 uuid.UUID          `json:"id"`
	AuditCycleClientID uuid.UUID          `json:"audit_cycle_client_id"`
	FrameworkID        uuid.UUID          `json:"framework_id"`
	FrameworkName      string             `json:"framework_name"`
	AssignedBy         pgtype.UUID        `json:"assigned_by"`
	AssignedAt         pgtype.Timestamptz `json:"assigned_at"`
	DueDate            pgtype.Date        `json:"due_date"`
	Status             *string            `json:"status"`
	AuditorID          pgtype.UUID        `json:"auditor_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	ClientID           uuid.UUID          `json:"client_id"`
	ClientName         string             `json:"client_name"`
}

func (q *Queries) GetAuditCycleFrameworks(ctx context.Context, auditCycleID uuid.UUID) ([]GetAuditCycleFrameworksRow, error) {
	rows, err := q.db.Query(ctx, GetAuditCycleFrameworks, auditCycleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAuditCycleFrameworksRow{}
	for rows.Next() {
		var i GetAuditCycleFrameworksRow
		if err := rows.Scan(
			&i.ID,
			&i.AuditCycleClientID,
			&i.FrameworkID,
			&i.FrameworkName,
			&i.AssignedBy,
			&i.AssignedAt,
			&i.DueDate,
			&i.Status,
			&i.AuditorID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClientID,
			&i.ClientName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetAuditCycleStats = `-- name: GetAuditCycleStats :one
SELECT 
    ac.id,
    ac.name,
    ac.status,
    COUNT(DISTINCT acc.client_id) as total_clients,
    COUNT(acf.id) as total_frameworks,
    COUNT(CASE WHEN acf.status = 'completed' THEN 1 END) as completed_frameworks,
    COUNT(CASE WHEN acf.status = 'in_progress' THEN 1 END) as in_progress_frameworks,
    COUNT(CASE WHEN acf.status = 'pending' THEN 1 END) as pending_frameworks,
    COUNT(CASE WHEN acf.status = 'overdue' THEN 1 END) as overdue_frameworks
FROM audit_cycles ac
LEFT JOIN audit_cycle_clients acc ON ac.id = acc.audit_cycle_id
LEFT JOIN audit_cycle_frameworks acf ON acc.id = acf.audit_cycle_client_id
WHERE ac.id = $1
GROUP BY ac.id, ac.name, ac.status
`

type GetAuditCycleStatsRow struct {
	ID                   uuid.UUID `json:"id"`
	Name                 string    `json:"name"`
	Status               *string   `json:"status"`
	TotalClients         int64     `json:"total_clients"`
	TotalFrameworks      int64     `json:"total_frameworks"`
	CompletedFrameworks  int64     `json:"completed_frameworks"`
	InProgressFrameworks int64     `json:"in_progress_frameworks"`
	PendingFrameworks    int64     `json:"pending_frameworks"`
	OverdueFrameworks    int64     `json:"overdue_frameworks"`
}

func (q *Queries) GetAuditCycleStats(ctx context.Context, id uuid.UUID) (GetAuditCycleStatsRow, error) {
	row := q.db.QueryRow(ctx, GetAuditCycleStats, id)
	var i GetAuditCycleStatsRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Status,
		&i.TotalClients,
		&i.TotalFrameworks,
		&i.CompletedFrameworks,
		&i.InProgressFrameworks,
		&i.PendingFrameworks,
		&i.OverdueFrameworks,
	)
	return i, err
}

const GetClientFrameworksInCycle = `-- name: GetClientFrameworksInCycle :many
SELECT 
    acf.id,
    acf.audit_cycle_client_id,
    acf.framework_id,
    acf.framework_name,
    acf.assigned_by,
    acf.assigned_at,
    acf.due_date,
    acf.status,
    acf.auditor_id,
    acf.created_at,
    acf.updated_at
FROM audit_cycle_frameworks acf
WHERE acf.audit_cycle_client_id = $1
ORDER BY acf.framework_name ASC
`

type GetClientFrameworksInCycleRow struct {
	ID                 uuid.UUID          `json:"id"`
	AuditCycleClientID uuid.UUID          `json:"audit_cycle_client_id"`
	FrameworkID        uuid.UUID          `json:"framework_id"`
	FrameworkName      string             `json:"framework_name"`
	AssignedBy         pgtype.UUID        `json:"assigned_by"`
	AssignedAt         pgtype.Timestamptz `json:"assigned_at"`
	DueDate            pgtype.Date        `json:"due_date"`
	Status             *string            `json:"status"`
	AuditorID          pgtype.UUID        `json:"auditor_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetClientFrameworksInCycle(ctx context.Context, auditCycleClientID uuid.UUID) ([]GetClientFrameworksInCycleRow, error) {
	rows, err := q.db.Query(ctx, GetClientFrameworksInCycle, auditCycleClientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetClientFrameworksInCycleRow{}
	for rows.Next() {
		var i GetClientFrameworksInCycleRow
		if err := rows.Scan(
			&i.ID,
			&i.AuditCycleClientID,
			&i.FrameworkID,
			&i.FrameworkName,
			&i.AssignedBy,
			&i.AssignedAt,
			&i.DueDate,
			&i.Status,
			&i.AuditorID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAuditCycles = `-- name: ListAuditCycles :many
SELECT id, name, description, start_date, end_date, status, created_by, created_at, updated_at FROM audit_cycles
ORDER BY created_at DESC
`

func (q *Queries) ListAuditCycles(ctx context.Context) ([]AuditCycle, error) {
	rows, err := q.db.Query(ctx, ListAuditCycles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditCycle{}
	for rows.Next() {
		var i AuditCycle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListAuditCyclesByStatus = `-- name: ListAuditCyclesByStatus :many
SELECT id, name, description, start_date, end_date, status, created_by, created_at, updated_at FROM audit_cycles
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListAuditCyclesByStatus(ctx context.Context, status *string) ([]AuditCycle, error) {
	rows, err := q.db.Query(ctx, ListAuditCyclesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AuditCycle{}
	for rows.Next() {
		var i AuditCycle
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.StartDate,
			&i.EndDate,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const RemoveClientFromAuditCycle = `-- name: RemoveClientFromAuditCycle :exec
DELETE FROM audit_cycle_clients
WHERE audit_cycle_id = $1 AND client_id = $2
`

type RemoveClientFromAuditCycleParams struct {
	AuditCycleID uuid.UUID `json:"audit_cycle_id"`
	ClientID     uuid.UUID `json:"client_id"`
}

func (q *Queries) RemoveClientFromAuditCycle(ctx context.Context, arg RemoveClientFromAuditCycleParams) error {
	_, err := q.db.Exec(ctx, RemoveClientFromAuditCycle, arg.AuditCycleID, arg.ClientID)
	return err
}

const UpdateAuditCycle = `-- name: UpdateAuditCycle :one
UPDATE audit_cycles
SET name = COALESCE($2, name),
    description = COALESCE($3, description),
    start_date = COALESCE($4, start_date),
    end_date = COALESCE($5, end_date),
    status = COALESCE($6, status)
WHERE id = $1
RETURNING id, name, description, start_date, end_date, status, created_by, created_at, updated_at
`

type UpdateAuditCycleParams struct {
	ID          uuid.UUID   `json:"id"`
	Name        string      `json:"name"`
	Description *string     `json:"description"`
	StartDate   pgtype.Date `json:"start_date"`
	EndDate     pgtype.Date `json:"end_date"`
	Status      *string     `json:"status"`
}

func (q *Queries) UpdateAuditCycle(ctx context.Context, arg UpdateAuditCycleParams) (AuditCycle, error) {
	row := q.db.QueryRow(ctx, UpdateAuditCycle,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.StartDate,
		arg.EndDate,
		arg.Status,
	)
	var i AuditCycle
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.StartDate,
		&i.EndDate,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const UpdateAuditCycleFrameworkStatus = `-- name: UpdateAuditCycleFrameworkStatus :one
UPDATE audit_cycle_frameworks
SET status = $2
WHERE id = $1
RETURNING id, audit_cycle_client_id, framework_id, framework_name, assigned_by, assigned_at, due_date, status, created_at, updated_at, auditor_id
`

type UpdateAuditCycleFrameworkStatusParams struct {
	ID     uuid.UUID `json:"id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdateAuditCycleFrameworkStatus(ctx context.Context, arg UpdateAuditCycleFrameworkStatusParams) (AuditCycleFramework, error) {
	row := q.db.QueryRow(ctx, UpdateAuditCycleFrameworkStatus, arg.ID, arg.Status)
	var i AuditCycleFramework
	err := row.Scan(
		&i.ID,
		&i.AuditCycleClientID,
		&i.FrameworkID,
		&i.FrameworkName,
		&i.AssignedBy,
		&i.AssignedAt,
		&i.DueDate,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AuditorID,
	)
	return i, err
}
